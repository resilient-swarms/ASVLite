#define YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* end standard C headers. */

#ifndef __cplusplus
extern int isatty(int);
#endif /* __cplusplus */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN (-32767 - 1)
#endif
#ifndef INT32_MIN
#define INT32_MIN (-2147483647 - 1)
#endif
#ifndef INT8_MAX
#define INT8_MAX (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR)(c))

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start)-1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin)
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state* YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
 *       access to the local variable yy_act. Since yyless() is a macro, it would break
 *       existing scanners that call yyless() from OUTSIDE yylex.
 *       One obvious solution it to make yy_act a global. I tried that, and saw
 *       a 5% performance hit in a non-yylineno scanner, because yy_act is
 *       normally declared as a register variable-- so it is not worth it.
 */
#define YY_LESS_LINENO(n)                                                                          \
  do                                                                                               \
  {                                                                                                \
    int yyl;                                                                                       \
    for (yyl = n; yyl < yyleng; ++yyl)                                                             \
      if (yytext[yyl] == '\n')                                                                     \
        --yylineno;                                                                                \
  } while (0)
#define YY_LINENO_REWIND_TO(dst)                                                                   \
  do                                                                                               \
  {                                                                                                \
    const char* p;                                                                                 \
    for (p = yy_cp - 1; p >= (dst); --p)                                                           \
      if (*p == '\n')                                                                              \
        --yylineno;                                                                                \
  } while (0)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n)                                                                                  \
  do                                                                                               \
  {                                                                                                \
    /* Undo effects of setting up yytext. */                                                       \
    int yyless_macro_arg = (n);                                                                    \
    YY_LESS_LINENO(yyless_macro_arg);                                                              \
    *yy_cp = (yy_hold_char);                                                                       \
    YY_RESTORE_YY_MORE_OFFSET(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ;        \
    YY_DO_BEFORE_ACTION; /* set up yytext again */                                                 \
  } while (0)
#define unput(c) yyunput(c, (yytext_ptr))

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
{
  FILE* yy_input_file;

  char* yy_ch_buf;  /* input buffer */
  char* yy_buf_pos; /* current position in input buffer */

  /* Size of input buffer in bytes, not including room for EOB
   * characters.
   */
  int yy_buf_size;

  /* Number of characters read into yy_ch_buf, not including EOB
   * characters.
   */
  int yy_n_chars;

  /* Whether we "own" the buffer - i.e., we know we created it,
   * and can realloc() it to grow it, and should free() it to
   * delete it.
   */
  int yy_is_our_buffer;

  /* Whether this is an "interactive" input source; if so, and
   * if we're using stdio for input, then we want to use getc()
   * instead of fread(), to make sure we stop fetching input after
   * each newline.
   */
  int yy_is_interactive;

  /* Whether we're considered to be at the beginning of a line.
   * If so, '^' rules will be active on the next match, otherwise
   * not.
   */
  int yy_at_bol;

  int yy_bs_lineno; /**< The line count. */
  int yy_bs_column; /**< The column count. */

  /* Whether to try to fill the input buffer when we reach the
   * end of it.
   */
  int yy_fill_buffer;

  int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
  /* When an EOF's been seen but there's still some text to process
   * then we mark the buffer as YY_EOF_PENDING, to indicate that we
   * shouldn't try reading from the input source any more.  We might
   * still have a bunch of tokens to match, though, because of
   * possible backing-up.
   *
   * When we actually see the EOF, we change the status to "new"
   * (via yyrestart()), so that the user can continue scanning by
   * just pointing yyin at a new input file.
   */
#define YY_BUFFER_EOF_PENDING 2
};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0;          /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0;          /**< capacity of stack. */
static YY_BUFFER_STATE* yy_buffer_stack = NULL; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ((yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars; /* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char* yy_c_buf_p = NULL;
static int yy_init = 0;  /* whether we need to initialize */
static int yy_start = 0; /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart(FILE* input_file);
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer);
YY_BUFFER_STATE yy_create_buffer(FILE* file, int size);
void yy_delete_buffer(YY_BUFFER_STATE b);
void yy_flush_buffer(YY_BUFFER_STATE b);
void yypush_buffer_state(YY_BUFFER_STATE new_buffer);
void yypop_buffer_state(void);

static void yyensure_buffer_stack(void);
static void yy_load_buffer_state(void);
static void yy_init_buffer(YY_BUFFER_STATE b, FILE* file);
#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER)

YY_BUFFER_STATE yy_scan_buffer(char* base, yy_size_t size);
YY_BUFFER_STATE yy_scan_string(const char* yy_str);
YY_BUFFER_STATE yy_scan_bytes(const char* bytes, int len);

void* yyalloc(yy_size_t);
void* yyrealloc(void*, yy_size_t);
void yyfree(void*);

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive)                                                         \
  {                                                                                                \
    if (!YY_CURRENT_BUFFER)                                                                        \
    {                                                                                              \
      yyensure_buffer_stack();                                                                     \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);                              \
    }                                                                                              \
    YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive;                                  \
  }
#define yy_set_bol(at_bol)                                                                         \
  {                                                                                                \
    if (!YY_CURRENT_BUFFER)                                                                        \
    {                                                                                              \
      yyensure_buffer_stack();                                                                     \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);                              \
    }                                                                                              \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;                                                  \
  }
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */
typedef flex_uint8_t YY_CHAR;

FILE *yyin = NULL, *yyout = NULL;

typedef int yy_state_type;

extern int yylineno;
int yylineno = 1;

extern char* yytext;
#ifdef yytext_ptr
#undef yytext_ptr
#endif
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state(void);
static yy_state_type yy_try_NUL_trans(yy_state_type current_state);
static int yy_get_next_buffer(void);
static void yynoreturn yy_fatal_error(const char* msg);

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION                                                                        \
  (yytext_ptr) = yy_bp;                                                                            \
  yyleng = (int)(yy_cp - yy_bp);                                                                   \
  (yy_hold_char) = *yy_cp;                                                                         \
  *yy_cp = '\0';                                                                                   \
  (yy_c_buf_p) = yy_cp;
#define YY_NUM_RULES 166
#define YY_END_OF_BUFFER 167
static const flex_int16_t yy_accept[981] = { 0, 0, 0, 167, 165, 129, 130, 130, 164, 165, 164, 164,
  165, 164, 164, 164, 164, 164, 164, 164, 127, 126, 164, 164, 164, 164, 118, 118, 118, 118, 118,
  118, 118, 118, 162, 165, 163, 164, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,
  118, 118, 118, 118, 118, 118, 118, 118, 164, 129, 13, 13, 15, 164, 165, 129, 157, 0, 16, 0, 136,
  150, 133, 154, 151, 0, 0, 0, 90, 91, 0, 0, 0, 0, 0, 148, 144, 146, 145, 147, 143, 141, 0, 119, 3,
  14, 149, 0, 120, 125, 0,

  0, 0, 0, 0, 126, 126, 126, 161, 135, 132, 134, 140, 158, 156, 159, 137, 118, 118, 118, 0, 0, 118,
  118, 118, 0, 118, 0, 131, 128, 0, 153, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,
  118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 81,
  118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,
  118, 152, 155, 129, 13, 15, 0, 0, 15, 15, 3, 12, 0, 0, 0, 17, 0, 0,

  0, 0, 0, 0, 142, 160, 0, 119, 119, 119, 0, 14, 14, 121, 120, 120, 125, 125, 0, 124, 0, 122, 123,
  126, 122, 138, 139, 118, 118, 118, 0, 0, 18, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,
  118, 118, 118, 118, 118, 118, 118, 79, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,
  118, 118, 118, 118, 118, 118, 118, 26, 118, 118, 118, 118, 65, 118, 83, 118, 118, 118, 118, 118,
  118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 69, 118, 118, 118,

  118, 118, 118, 118, 118, 118, 85, 0, 12, 15, 2, 12, 12, 6, 12, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 119, 0, 119, 1, 5, 0, 121, 121, 121, 120, 0, 120, 125, 122, 0, 124, 124, 0, 122, 122, 0,
  123, 123, 123, 122, 122, 118, 118, 118, 0, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,
  118, 118, 118, 118, 118, 118, 118, 118, 19, 118, 118, 30, 118, 25, 118, 118, 118, 118, 118, 118,
  118, 118, 47, 118, 118, 118, 118, 118, 118, 24, 118,

  118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 0, 118, 118,
  118, 118, 118, 118, 118, 118, 118, 118, 29, 118, 118, 118, 118, 118, 2, 12, 12, 6, 12, 12, 12, 6,
  5, 7, 8, 0, 0, 16, 17, 0, 0, 0, 0, 0, 0, 0, 0, 119, 0, 119, 119, 5, 121, 0, 121, 120, 0, 120, 120,
  122, 122, 124, 122, 123, 123, 123, 123, 122, 118, 118, 118, 102, 118, 118, 118, 118, 118, 118,
  118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,

  118, 118, 88, 70, 118, 118, 42, 89, 50, 118, 118, 118, 118, 118, 118, 118, 21, 118, 118, 118, 118,
  118, 118, 118, 118, 118, 82, 118, 118, 118, 118, 118, 118, 23, 118, 118, 118, 118, 118, 0, 118,
  118, 118, 118, 68, 118, 118, 48, 118, 64, 118, 118, 118, 118, 118, 118, 12, 12, 6, 7, 8, 12, 12,
  12, 5, 7, 8, 0, 0, 17, 0, 0, 0, 0, 0, 0, 0, 0, 119, 121, 0, 121, 121, 120, 122, 118, 118, 118,
  102, 96, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118,

  118, 118, 118, 118, 118, 118, 118, 80, 87, 118, 118, 118, 118, 118, 118, 66, 20, 118, 118, 59, 54,
  55, 118, 118, 118, 118, 84, 118, 118, 118, 118, 118, 44, 118, 118, 118, 28, 118, 118, 57, 0, 0, 0,
  0, 118, 43, 118, 118, 118, 118, 118, 118, 118, 118, 118, 118, 86, 12, 12, 12, 7, 8, 12, 12, 12, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 121, 118, 118, 118, 95, 118, 108, 118, 118, 110, 118, 118, 114, 118,
  118, 118, 22, 118, 118, 118, 118, 104, 118, 118, 118,

  118, 118, 73, 118, 118, 118, 52, 118, 118, 117, 118, 118, 45, 118, 0, 118, 118, 118, 34, 34, 118,
  118, 0, 0, 0, 0, 0, 0, 99, 99, 118, 118, 62, 118, 118, 49, 118, 118, 118, 33, 12, 12, 12, 12, 12,
  12, 0, 0, 0, 0, 0, 93, 94, 0, 0, 0, 0, 0, 96, 96, 37, 105, 106, 118, 118, 118, 118, 118, 118, 111,
  118, 118, 118, 31, 32, 118, 118, 72, 118, 67, 98, 98, 118, 71, 118, 53, 97, 97, 0, 118, 0, 78,
  118, 0, 41, 35, 35, 118, 118, 0,

  0, 0, 0, 0, 0, 60, 118, 61, 27, 51, 118, 118, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0, 0, 92, 0, 0, 0,
  0, 109, 118, 118, 118, 118, 118, 118, 118, 56, 118, 63, 118, 0, 46, 0, 118, 118, 118, 0, 0, 0, 0,
  0, 0, 118, 118, 118, 12, 12, 12, 10, 12, 12, 0, 0, 0, 0, 118, 118, 113, 116, 76, 118, 36, 36, 0,
  0, 0, 118, 118, 118, 0, 0, 0, 0, 0, 0, 118, 118, 118, 10, 12, 12, 10, 12, 12, 0, 4, 118, 118, 118,
  118,

  0, 0, 0, 118, 118, 74, 0, 0, 0, 0, 0, 0, 118, 118, 118, 10, 12, 12, 12, 12, 0, 118, 118, 115, 75,
  0, 0, 0, 118, 118, 0, 0, 0, 0, 58, 100, 118, 12, 12, 11, 12, 0, 107, 112, 0, 0, 0, 38, 118, 103,
  0, 118, 11, 12, 11, 12, 0, 0, 39, 0, 118, 0, 118, 11, 12, 12, 0, 0, 118, 118, 12, 9, 0, 40, 77,
  101, 9, 9, 9, 0 };

static const YY_CHAR yy_ec[256] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 4, 5, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 7, 8, 9, 1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
  22, 23, 24, 25, 26, 27, 26, 28, 29, 30, 17, 31, 32, 33, 1, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
  44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 42, 56, 57, 58, 42, 59, 60, 61, 62, 63, 1, 64, 65,
  66, 67,

  68, 69, 70, 71, 72, 42, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,
  91, 17, 1, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
  92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
  92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
  92, 92, 92,

  92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
  92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
  92, 92, 92, 92, 92, 92, 92 };

static const YY_CHAR yy_meta[93] = { 0, 1, 2, 3, 4, 5, 2, 1, 1, 1, 1, 6, 7, 1, 4, 6, 1, 1, 1, 8, 1,
  9, 9, 10, 10, 10, 10, 10, 10, 10, 11, 1, 1, 1, 1, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 1, 1, 1, 1, 13, 12, 12, 12, 12, 12, 12, 13, 13,
  13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 1, 1, 1, 14

};

static const flex_int16_t yy_base[1087] = { 0, 0, 91, 2829, 2830, 93, 2830, 2830, 2796, 90, 71, 91,
  2767, 103, 2830, 2794, 94, 89, 120, 97, 155, 174, 83, 121, 2793, 87, 2774, 0, 2788, 116, 52, 2814,
  152, 2778, 152, 127, 2830, 2788, 174, 87, 113, 98, 139, 51, 91, 111, 2742, 2735, 142, 149, 53,
  2749, 162, 167, 224, 168, 2750, 2738, 124, 253, 2830, 2830, 2754, 231, 2741, 215, 2830, 197, 2749,
  2806, 2830, 2830, 2830, 2830, 2830, 206, 236, 266, 2830, 2830, 158, 2780, 230, 231, 201, 2830,
  2830, 2830, 2830, 2830, 2794, 2830, 2789, 267, 260, 263, 2830, 286, 315, 334, 353,

  263, 372, 0, 382, 401, 0, 420, 2830, 2830, 2830, 2830, 2775, 2830, 2830, 2830, 2774, 0, 2762,
  2758, 270, 2743, 2794, 2752, 2770, 2786, 2750, 412, 2830, 2830, 2794, 2830, 242, 2728, 2718, 2714,
  2722, 386, 2720, 2724, 2708, 2707, 2711, 2705, 2722, 2721, 222, 251, 2701, 2707, 2699, 171, 2704,
  2708, 244, 2697, 2702, 2695, 2701, 2690, 251, 2700, 2705, 2709, 2689, 227, 2705, 210, 2692, 257,
  2696, 267, 2692, 2686, 2678, 2686, 379, 251, 2691, 2682, 276, 2688, 2689, 2679, 2830, 2830, 454,
  2830, 2698, 349, 2685, 2696, 429, 447, 466, 276, 0, 462, 2692, 2724, 2723,

  341, 143, 319, 409, 2830, 2830, 480, 502, 0, 521, 2721, 0, 2720, 539, 0, 558, 0, 572, 587, 471,
  596, 614, 632, 0, 652, 2830, 2830, 2711, 2703, 2712, 2717, 2733, 2830, 2710, 2672, 2666, 2666,
  2661, 2676, 2659, 2656, 254, 2669, 2672, 2648, 2630, 2638, 2623, 2611, 2598, 2601, 2586, 417,
  2576, 2583, 2556, 2554, 2544, 2540, 2534, 2543, 2516, 2505, 2500, 2483, 2481, 2482, 2480, 2473,
  2464, 0, 2453, 2458, 2461, 2446, 0, 2414, 2423, 2398, 2378, 2376, 2350, 2332, 2320, 2322, 2318,
  2308, 2298, 2296, 2301, 2276, 2276, 2322, 404, 2268, 442, 0, 2275, 2261, 2260,

  2253, 2242, 2254, 2252, 313, 2249, 2245, 470, 682, 458, 2263, 0, 351, 2257, 344, 2204, 2197, 0,
  377, 0, 401, 481, 256, 449, 466, 452, 450, 465, 0, 682, 700, 2830, 0, 709, 727, 0, 746, 0, 755,
  775, 0, 793, 476, 670, 0, 802, 820, 0, 0, 838, 896, 0, 858, 0, 2226, 2235, 2216, 0, 2204, 2170,
  2151, 2144, 2130, 2114, 2102, 2074, 2079, 2061, 2069, 2051, 2045, 2057, 2037, 2046, 2038, 2031,
  2033, 0, 2019, 2012, 0, 2016, 491, 2000, 2006, 1996, 1991, 1987, 1983, 1985, 1981, 0, 1979, 1965,
  1957, 1960, 1947, 1949, 0, 1949,

  1922, 1936, 1933, 1922, 1935, 1912, 1909, 1899, 1889, 1882, 1868, 1864, 1859, 453, 1875, 1865,
  1860, 1900, 1849, 1853, 1839, 1846, 1820, 617, 1812, 1805, 1804, 1790, 0, 1786, 1782, 1782, 1770,
  1768, 2830, 0, 515, 0, 463, 524, 1762, 0, 0, 0, 0, 1753, 1740, 0, 0, 508, 539, 505, 559, 572, 602,
  561, 562, 916, 867, 945, 0, 0, 0, 925, 963, 981, 990, 1008, 0, 1026, 0, 0, 0, 1044, 1102, 0, 0, 0,
  1748, 1761, 1749, 0, 1744, 1710, 1713, 1704, 1699, 1696, 1682, 1665, 1678, 1677, 1668, 1659, 1713,
  1669, 1656, 1671, 1655, 1671,

  1655, 1666, 0, 0, 1705, 1708, 0, 0, 582, 1643, 1655, 1660, 1659, 1654, 1659, 1648, 0, 1656, 1654,
  1657, 1642, 1637, 1646, 1634, 1630, 1629, 0, 1646, 1627, 1642, 1641, 1624, 1637, 0, 1630, 1636,
  1620, 1638, 1634, 713, 1629, 1616, 1633, 1629, 0, 1627, 1630, 0, 1617, 0, 1590, 1581, 1585, 1579,
  1587, 1570, 598, 1580, 0, 0, 0, 1612, 1607, 1564, 0, 0, 0, 1576, 1563, 0, 575, 655, 469, 600, 727,
  632, 803, 664, 1064, 1122, 1073, 1151, 0, 1169, 0, 1590, 1604, 1603, 0, 1589, 1574, 1571, 1564,
  1552, 1570, 1566, 1560, 1557, 1566, 1548,

  1558, 1598, 1547, 1541, 1556, 1553, 1537, 0, 0, 1554, 1553, 1549, 1528, 1535, 1530, 0, 0, 1545,
  1538, 0, 0, 0, 1534, 1540, 1543, 1528, 0, 1525, 1527, 1528, 1534, 1519, 738, 1494, 1481, 1479, 0,
  1198, 1477, 1495, 1476, 1473, 1474, 828, 1290, 0, 1472, 1490, 1483, 1476, 1482, 1475, 1474, 1494,
  1480, 1463, 0, 1509, 1504, 1461, 0, 0, 1494, 1503, 1473, 1463, 1468, 635, 683, 1231, 529, 728,
  805, 776, 806, 1226, 1474, 1486, 1476, 0, 1448, 0, 1462, 1447, 0, 1463, 1460, 0, 1450, 1445, 1458,
  0, 1457, 1448, 1445, 1454, 0, 1435, 1434, 1451,

  1436, 1445, 0, 1449, 1429, 1382, 0, 1444, 1427, 1407, 1389, 1474, 805, 1400, 849, 1387, 1388, 953,
  2830, 0, 1566, 507, 1382, 1389, 1380, 1373, 1388, 1379, 2830, 0, 1390, 1383, 0, 1388, 1388, 0,
  1386, 1371, 1375, 0, 1404, 1412, 1382, 1408, 1392, 1360, 1371, 1374, 688, 603, 1101, 2830, 1407,
  1323, 685, 804, 687, 964, 1386, 1385, 0, 0, 0, 1358, 1359, 1349, 1357, 1361, 1354, 0, 1361, 1350,
  1345, 0, 0, 1296, 1296, 0, 1309, 0, 2830, 0, 1306, 0, 1291, 0, 2830, 0, 976, 1305, 1297, 0, 1290,
  993, 2830, 2830, 0, 1287, 1303, 1286,

  1291, 1283, 1294, 1273, 1288, 0, 1282, 0, 0, 0, 1277, 1289, 1316, 1300, 1268, 1341, 1303, 1263,
  1256, 1261, 1328, 1415, 1150, 2830, 689, 712, 717, 735, 0, 1209, 1203, 1218, 1209, 1200, 1206,
  1197, 0, 1214, 0, 1658, 1203, 909, 1199, 1207, 1193, 1192, 1204, 1193, 1202, 1206, 1200, 1190,
  1199, 1192, 1195, 1256, 1213, 1173, 0, 1195, 1163, 1153, 1121, 782, 783, 1122, 1119, 0, 1122, 0,
  1103, 2830, 0, 1106, 1037, 1100, 1082, 1089, 1072, 1058, 1039, 1056, 1037, 1054, 1045, 1041, 1002,
  1024, 0, 337, 341, 0, 403, 475, 494, 2830, 540, 543, 568, 565,

  567, 589, 605, 632, 680, 0, 713, 757, 763, 0, 757, 0, 779, 788, 815, 0, 850, 817, 895, 841, 834,
  852, 864, 0, 0, 848, 899, 1130, 911, 898, 0, 934, 0, 0, 0, 0, 920, 995, 949, 0, 945, 952, 0, 0,
  1156, 943, 1237, 2830, 962, 0, 945, 969, 0, 967, 0, 969, 969, 1334, 2830, 977, 978, 0, 984, 0,
  985, 1032, 987, 1339, 982, 1004, 1045, 0, 1420, 2830, 0, 0, 0, 0, 0, 2830, 1750, 1764, 1777, 1785,
  1791, 1805, 1811, 1819, 1833, 1839, 1847, 1853, 1857, 1871, 1885, 1888, 1894, 1902, 1908, 1914,

  1922, 1930, 1938, 1946, 1960, 1974, 1980, 1983, 1992, 1998, 2006, 2020, 2028, 2034, 2040, 2048,
  2054, 2062, 2070, 2076, 2084, 2090, 2096, 2102, 2110, 2116, 2124, 2130, 2136, 2139, 2153, 2167,
  2181, 2195, 2209, 2223, 2237, 2243, 2249, 2255, 2263, 2271, 2277, 2291, 2297, 2305, 2313, 2321,
  2327, 2335, 2341, 2347, 2353, 2361, 2367, 2373, 2379, 2385, 2399, 2413, 2427, 2441, 2455, 2469,
  2483, 2497, 2503, 2509, 2517, 2525, 2533, 2539, 2547, 2553, 2567, 2581, 2595, 2609, 2623, 2637,
  2651, 2665, 2679, 2693, 2707, 2721 };

static const flex_int16_t yy_def[1087] = { 0, 980, 1, 980, 980, 980, 980, 980, 980, 981, 980, 980,
  982, 983, 980, 980, 980, 980, 980, 980, 980, 984, 980, 980, 980, 980, 985, 985, 985, 985, 985,
  985, 985, 985, 980, 980, 980, 980, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985,
  985, 985, 985, 985, 985, 985, 985, 985, 980, 980, 980, 980, 986, 980, 980, 980, 980, 981, 980,
  981, 980, 980, 980, 980, 980, 982, 982, 983, 980, 980, 987, 987, 987, 987, 987, 980, 980, 980,
  980, 980, 980, 980, 980, 988, 980, 989, 980, 980, 990, 991, 980,

  980, 980, 992, 980, 984, 993, 993, 980, 980, 980, 980, 980, 980, 980, 980, 980, 985, 985, 985,
  981, 982, 985, 985, 985, 994, 985, 980, 980, 980, 980, 980, 985, 985, 985, 985, 985, 985, 985,
  985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985,
  985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985,
  985, 985, 985, 985, 985, 985, 985, 980, 980, 980, 980, 986, 980, 980, 986, 986, 980, 995, 980,
  996, 981, 980, 987, 980,

  987, 987, 987, 987, 980, 980, 980, 988, 997, 997, 980, 989, 989, 998, 999, 999, 1000, 1000, 980,
  1001, 980, 1002, 1003, 993, 1004, 980, 980, 985, 985, 985, 980, 994, 980, 985, 985, 985, 985, 985,
  985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985,
  985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985,
  985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985, 985,
  985, 985, 985, 985, 985,

  985, 985, 985, 985, 985, 985, 985, 980, 1005, 986, 980, 995, 995, 1006, 995, 980, 980, 1007, 981,
  1008, 1009, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 997, 980, 1011, 980, 1012, 980, 1013, 1014,
  1014, 1015, 980, 1016, 1017, 1018, 980, 1019, 1020, 980, 1021, 1022, 1023, 1024, 1025, 1026, 1027,
  1028, 1029, 1029, 1029, 1030, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029,
  1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029,
  1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029,

  1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029,
  1029, 980, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029,
  1029, 1029, 980, 1031, 1031, 1032, 1031, 1033, 1033, 1034, 1035, 1036, 1037, 980, 980, 1038, 1039,
  1040, 1040, 1040, 1040, 1040, 1040, 1040, 1040, 1041, 980, 1042, 1043, 1044, 1045, 980, 1046,
  1047, 980, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1054, 1055, 1055, 1056, 1057, 1057, 1057,
  1058, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057,
  1057, 1057, 1057,

  1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057,
  1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057,
  1057, 1057, 1057, 1057, 1057, 1057, 1057, 980, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057,
  1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1059, 1059, 1060, 1061, 1062, 1063, 1063, 1063,
  1064, 1065, 1066, 980, 980, 1067, 1068, 1068, 1068, 1068, 1068, 1068, 1068, 1068, 1069, 1070, 980,
  1071, 1072, 1073, 1074, 1057, 1057, 1057, 1058, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057,
  1057, 1057, 1057,

  1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057,
  1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057,
  1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 980, 980, 980, 980, 1057, 1057, 1057, 1057, 1057,
  1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1059, 1059, 1059, 1061, 1062, 1063, 1063, 1063,
  980, 980, 1068, 1068, 1068, 1068, 1068, 1068, 1068, 1068, 1070, 1057, 1057, 1057, 1057, 1057,
  1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057,
  1057, 1057, 1057,

  1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 980, 1057,
  1057, 1057, 980, 1057, 1057, 1057, 980, 980, 980, 980, 980, 980, 980, 1057, 1057, 1057, 1057,
  1057, 1057, 1057, 1057, 1057, 1057, 1057, 1059, 1059, 1059, 1063, 1063, 1063, 980, 980, 1068,
  1068, 980, 980, 1068, 1068, 1068, 1068, 1068, 1068, 1057, 1057, 1057, 1057, 1057, 1057, 1057,
  1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 980,
  1057, 1057, 1057, 1057, 1057, 980, 1057, 980, 1057, 980, 1057, 1057, 980, 980, 980, 1057, 1057,
  1057, 980,

  980, 980, 980, 980, 980, 1057, 1057, 1057, 1057, 1057, 1057, 1057, 1059, 1059, 1059, 1063, 1063,
  1063, 980, 980, 1068, 1068, 980, 980, 1068, 1068, 1068, 1068, 1057, 1057, 1057, 1057, 1057, 1057,
  1057, 1057, 1057, 1057, 1057, 1057, 980, 1057, 980, 1057, 1057, 1057, 980, 980, 980, 980, 980,
  980, 1057, 1057, 1057, 1059, 1059, 1059, 1075, 1063, 1063, 980, 980, 1068, 1068, 1057, 1057, 1057,
  1057, 1057, 1057, 980, 1057, 980, 980, 980, 1057, 1057, 1057, 980, 980, 980, 980, 980, 980, 1057,
  1057, 1057, 1076, 1059, 1059, 1075, 1063, 1063, 980, 980, 1057, 1057, 1057, 1057,

  980, 980, 980, 1057, 1057, 1057, 980, 980, 980, 1077, 980, 1078, 1057, 1057, 1057, 1076, 1059,
  1059, 1063, 1063, 980, 1057, 1057, 1057, 1057, 980, 980, 980, 1057, 1057, 1079, 980, 1080, 1081,
  1057, 1057, 1057, 1059, 1059, 1082, 1063, 980, 1057, 1057, 980, 980, 980, 980, 1057, 1057, 980,
  1057, 1083, 1059, 1082, 1063, 980, 980, 980, 980, 1057, 1084, 1057, 1083, 1059, 1063, 980, 980,
  1057, 1057, 1059, 1085, 980, 980, 1057, 1057, 1086, 1085, 1086, 0, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,

  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 980, 980 };

static const flex_int16_t yy_nxt[2923] = { 0, 4, 5, 6, 7, 7, 5, 8, 9, 4, 10, 11, 12, 13, 14, 15, 16,
  14, 17, 18, 19, 20, 21, 21, 21, 21, 21, 21, 21, 21, 22, 23, 24, 25, 4, 26, 27, 28, 27, 27, 27, 27,
  27, 27, 27, 27, 29, 27, 27, 27, 27, 30, 31, 27, 27, 32, 33, 27, 27, 34, 35, 36, 37, 38, 39, 40,
  41, 42, 43, 44, 27, 27, 45, 27, 46, 47, 48, 49, 50, 27, 51, 52, 53, 54, 55, 56, 57, 27, 27, 14,
  58, 14, 27, 59, 60, 65, 61, 59, 68, 65, 62,

  70, 73, 71, 72, 77, 77, 88, 77, 77, 86, 63, 94, 108, 78, 123, 109, 95, 79, 115, 116, 89, 90, 74,
  120, 64, 87, 150, 121, 96, 129, 110, 130, 165, 124, 91, 166, 151, 80, 92, 82, 93, 93, 93, 93, 93,
  93, 93, 93, 93, 69, 111, 112, 113, 127, 127, 184, 127, 127, 83, 120, 138, 143, 139, 121, 152, 84,
  97, 122, 144, 140, 153, 145, 200, 98, 146, 99, 99, 99, 99, 99, 99, 99, 99, 100, 141, 104, 154,
  200, 323, 142, 101, 155, 98, 102, 105, 105, 105, 105, 105, 105,

  105, 105, 105, 122, 68, 158, 147, 201, 132, 159, 128, 103, 107, 185, 133, 148, 65, 198, 160, 101,
  65, 134, 102, 135, 161, 149, 162, 136, 163, 164, 200, 120, 168, 169, 172, 121, 137, 173, 980, 179,
  103, 107, 170, 171, 180, 193, 174, 75, 266, 181, 194, 176, 267, 175, 186, 187, 69, 187, 186, 200,
  200, 188, 96, 204, 202, 76, 211, 77, 77, 213, 77, 77, 189, 203, 211, 122, 78, 68, 207, 286, 79,
  287, 213, 220, 220, 200, 190, 208, 208, 208, 208, 208, 208, 208, 208, 208, 258, 259, 283, 177,

  80, 451, 82, 284, 178, 210, 99, 99, 99, 99, 99, 99, 99, 99, 100, 235, 260, 270, 277, 261, 367, 83,
  299, 236, 262, 271, 289, 368, 84, 69, 292, 300, 278, 293, 210, 214, 214, 214, 214, 214, 214, 214,
  214, 214, 290, 97, 294, 303, 200, 304, 316, 317, 98, 216, 99, 99, 99, 99, 99, 99, 99, 99, 100,
  308, 219, 431, 324, 432, 309, 440, 200, 98, 218, 100, 100, 100, 100, 100, 100, 100, 100, 100, 216,
  322, 68, 917, 120, 221, 441, 221, 121, 102, 222, 222, 222, 222, 222, 222, 222, 222,

  222, 218, 105, 105, 105, 105, 105, 105, 105, 105, 105, 78, 104, 127, 127, 79, 127, 127, 918, 98,
  102, 105, 105, 105, 105, 105, 105, 105, 105, 105, 122, 191, 444, 310, 445, 221, 69, 221, 200, 107,
  225, 225, 225, 225, 225, 225, 225, 225, 225, 241, 919, 242, 243, 311, 244, 186, 187, 245, 187,
  186, 191, 311, 188, 246, 319, 247, 248, 249, 107, 68, 128, 313, 314, 189, 325, 419, 435, 326, 200,
  200, 379, 200, 343, 452, 435, 314, 420, 190, 192, 327, 328, 344, 344, 380, 200, 200, 344, 344,
  200, 315,

  208, 208, 208, 208, 208, 208, 208, 208, 208, 422, 200, 670, 505, 207, 506, 455, 535, 192, 423,
  450, 536, 69, 208, 208, 208, 208, 208, 208, 208, 208, 208, 456, 453, 557, 200, 457, 330, 200, 330,
  454, 210, 331, 331, 331, 331, 331, 331, 331, 331, 331, 334, 560, 558, 561, 573, 571, 920, 921,
  200, 335, 335, 335, 335, 335, 335, 335, 335, 335, 200, 210, 798, 562, 799, 339, 572, 339, 563,
  337, 340, 340, 340, 340, 340, 340, 340, 340, 340, 221, 200, 221, 200, 200, 342, 342, 342, 342,
  342, 342, 342, 342,

  342, 200, 754, 922, 200, 923, 337, 100, 100, 100, 100, 100, 100, 100, 100, 100, 222, 222, 222,
  222, 222, 222, 222, 222, 222, 346, 574, 577, 668, 200, 924, 200, 200, 578, 347, 347, 347, 347,
  347, 347, 347, 347, 347, 349, 612, 658, 925, 822, 926, 613, 659, 575, 350, 350, 350, 350, 350,
  350, 350, 350, 350, 200, 927, 346, 200, 671, 351, 351, 351, 351, 351, 351, 353, 353, 353, 353,
  353, 353, 353, 353, 353, 343, 576, 546, 200, 928, 749, 437, 438, 669, 344, 344, 547, 200, 929,
  351, 351, 351, 351, 351,

  351, 438, 458, 458, 458, 458, 458, 458, 458, 458, 458, 459, 200, 673, 200, 439, 200, 200, 200,
  750, 460, 460, 460, 460, 460, 460, 460, 460, 460, 335, 335, 335, 335, 335, 335, 335, 335, 335,
  334, 715, 715, 200, 715, 715, 675, 821, 200, 335, 335, 335, 335, 335, 335, 335, 335, 335, 200,
  200, 825, 930, 827, 464, 754, 464, 200, 337, 465, 465, 465, 465, 465, 465, 465, 465, 465, 466,
  466, 466, 466, 466, 466, 466, 466, 466, 641, 864, 467, 931, 642, 643, 754, 755, 672, 644, 337,
  468, 468, 468, 468, 468,

  468, 468, 468, 468, 346, 200, 789, 789, 865, 789, 789, 200, 200, 470, 470, 470, 470, 470, 470,
  470, 470, 470, 347, 347, 347, 347, 347, 347, 347, 347, 347, 346, 200, 200, 200, 200, 932, 933,
  934, 757, 347, 347, 347, 347, 347, 347, 347, 347, 347, 349, 715, 715, 935, 715, 715, 754, 754,
  936, 350, 350, 350, 350, 350, 350, 350, 350, 350, 826, 674, 346, 756, 758, 351, 351, 351, 351,
  351, 351, 353, 353, 353, 353, 353, 353, 353, 353, 353, 579, 579, 579, 579, 579, 579, 579, 579,
  579, 937, 938, 939, 726,

  940, 351, 351, 351, 351, 351, 351, 349, 727, 728, 875, 875, 941, 875, 875, 942, 474, 474, 474,
  474, 474, 474, 474, 474, 474, 943, 944, 459, 945, 791, 475, 475, 475, 475, 475, 475, 579, 579,
  579, 579, 579, 579, 579, 579, 579, 580, 580, 580, 580, 580, 580, 580, 580, 580, 794, 794, 459,
  794, 794, 475, 475, 475, 475, 475, 475, 460, 460, 460, 460, 460, 460, 460, 460, 460, 581, 946,
  949, 789, 789, 950, 789, 789, 795, 582, 582, 582, 582, 582, 582, 582, 582, 582, 467, 200, 794,
  794, 951, 794, 794, 952,

  953, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584,
  467, 954, 956, 795, 957, 960, 961, 962, 828, 468, 468, 468, 468, 468, 468, 468, 468, 468, 346,
  875, 875, 963, 875, 875, 965, 966, 967, 470, 470, 470, 470, 470, 470, 470, 470, 470, 349, 841,
  968, 969, 970, 971, 972, 896, 975, 474, 474, 474, 474, 474, 474, 474, 474, 474, 976, 977, 459,
  915, 914, 475, 475, 475, 475, 475, 475, 579, 579, 579, 579, 579, 579, 579, 579, 579, 676, 676,
  676, 676, 676, 676, 676,

  676, 676, 751, 751, 913, 751, 751, 475, 475, 475, 475, 475, 475, 349, 912, 752, 911, 902, 910,
  909, 908, 907, 474, 474, 474, 474, 474, 474, 474, 474, 474, 947, 947, 581, 947, 947, 475, 475,
  475, 475, 475, 475, 676, 676, 676, 676, 676, 676, 676, 676, 676, 823, 823, 906, 823, 823, 905,
  958, 958, 948, 958, 958, 581, 904, 824, 475, 475, 475, 475, 475, 475, 582, 582, 582, 582, 582,
  582, 582, 582, 582, 467, 903, 901, 900, 899, 959, 898, 897, 896, 584, 584, 584, 584, 584, 584,
  584, 584, 584, 719, 719,

  719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 720,
  720, 720, 720, 720, 720, 720, 720, 720, 719, 719, 719, 719, 719, 751, 751, 895, 751, 751, 581,
  947, 947, 894, 947, 947, 893, 891, 752, 676, 676, 676, 676, 676, 676, 676, 676, 676, 890, 719,
  719, 719, 719, 200, 889, 888, 887, 886, 885, 948, 884, 883, 882, 881, 880, 879, 878, 877, 876,
  874, 871, 870, 688, 753, 869, 688, 868, 867, 866, 719, 719, 719, 720, 729, 729, 729, 729, 729,
  729, 729, 729, 729, 729,

  729, 729, 729, 729, 729, 729, 729, 729, 729, 729, 730, 730, 730, 730, 730, 730, 730, 730, 730,
  729, 729, 729, 729, 729, 823, 823, 863, 823, 823, 751, 751, 862, 751, 751, 861, 958, 958, 824,
  958, 958, 973, 973, 752, 973, 973, 860, 859, 858, 729, 729, 729, 729, 200, 857, 856, 855, 854,
  200, 853, 852, 851, 850, 849, 959, 848, 847, 846, 845, 974, 844, 843, 842, 840, 839, 838, 837,
  836, 753, 729, 729, 729, 730, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781,
  781, 781, 781, 781, 781,

  781, 781, 782, 782, 782, 782, 782, 782, 782, 782, 782, 781, 781, 781, 781, 781, 751, 751, 835,
  751, 751, 973, 973, 688, 973, 973, 834, 833, 832, 752, 688, 831, 830, 829, 680, 680, 200, 820,
  819, 818, 781, 781, 781, 781, 200, 817, 816, 815, 814, 974, 813, 812, 811, 810, 809, 808, 807,
  806, 805, 804, 803, 802, 801, 800, 753, 793, 792, 790, 786, 785, 781, 781, 781, 782, 787, 787,
  787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 788,
  788, 788, 788, 788, 788,

  788, 788, 788, 787, 787, 787, 787, 787, 784, 783, 780, 779, 778, 777, 776, 775, 774, 773, 772,
  771, 770, 769, 768, 767, 766, 765, 764, 763, 762, 761, 760, 759, 787, 787, 787, 787, 748, 747,
  746, 745, 744, 743, 742, 741, 740, 739, 738, 737, 736, 735, 734, 733, 732, 731, 725, 724, 723,
  722, 721, 718, 717, 716, 787, 787, 787, 788, 796, 796, 796, 796, 796, 796, 796, 796, 796, 796,
  796, 796, 796, 796, 796, 796, 796, 796, 796, 796, 797, 797, 797, 797, 797, 797, 797, 797, 797,
  796, 796, 796, 796, 796,

  714, 713, 712, 711, 710, 709, 708, 707, 706, 705, 704, 703, 702, 701, 700, 699, 698, 697, 696,
  695, 694, 693, 692, 691, 796, 796, 796, 796, 690, 689, 688, 687, 686, 685, 684, 683, 682, 681,
  680, 679, 678, 677, 667, 666, 665, 664, 663, 660, 657, 656, 655, 654, 653, 652, 796, 796, 796,
  797, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872, 872,
  872, 872, 873, 873, 873, 873, 873, 873, 873, 873, 873, 872, 872, 872, 872, 872, 651, 650, 649,
  648, 647, 646, 645, 640,

  639, 638, 637, 636, 635, 634, 633, 632, 631, 630, 629, 628, 627, 626, 625, 624, 872, 872, 872,
  872, 623, 622, 621, 620, 619, 618, 617, 616, 615, 614, 611, 610, 609, 608, 607, 606, 605, 604,
  603, 602, 601, 600, 599, 598, 597, 596, 872, 872, 872, 873, 67, 67, 67, 67, 67, 67, 67, 67, 67,
  67, 67, 67, 67, 67, 75, 75, 75, 75, 75, 75, 595, 75, 75, 75, 75, 75, 75, 75, 81, 81, 594, 81, 81,
  593, 592, 591, 590, 588, 81, 81, 81, 106, 106, 106, 106, 587, 106, 106, 106, 117,

  117, 586, 117, 117, 117, 191, 191, 569, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191, 191,
  199, 199, 199, 199, 199, 199, 209, 568, 209, 209, 564, 209, 209, 209, 212, 212, 556, 212, 212,
  212, 212, 212, 212, 212, 212, 212, 212, 212, 215, 215, 555, 215, 215, 215, 217, 217, 217, 217,
  554, 217, 217, 217, 223, 223, 553, 223, 224, 224, 552, 224, 224, 224, 232, 551, 550, 549, 232,
  232, 232, 232, 232, 232, 232, 232, 232, 232, 312, 312, 548, 312, 312, 312, 312, 312, 312, 312,
  312, 312, 312, 312, 318,

  318, 318, 329, 329, 545, 329, 329, 329, 336, 544, 336, 336, 543, 336, 336, 336, 338, 338, 542,
  338, 338, 338, 341, 341, 541, 341, 341, 341, 345, 540, 345, 539, 538, 345, 345, 345, 348, 537,
  348, 348, 534, 348, 348, 348, 352, 533, 352, 352, 532, 352, 352, 352, 354, 531, 354, 354, 530,
  354, 354, 354, 436, 436, 529, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 442, 442,
  528, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 442, 448, 448, 527, 448, 448, 448, 449,
  449, 449, 81, 526, 525,

  524, 523, 522, 81, 81, 81, 199, 199, 199, 199, 199, 199, 461, 521, 461, 461, 520, 461, 461, 461,
  462, 462, 519, 462, 462, 462, 462, 462, 462, 462, 462, 462, 462, 462, 336, 518, 336, 336, 517,
  336, 336, 336, 463, 463, 516, 463, 463, 463, 338, 338, 515, 338, 338, 338, 469, 514, 469, 469,
  513, 469, 469, 469, 341, 341, 512, 341, 341, 341, 471, 511, 471, 471, 510, 471, 471, 471, 345,
  509, 345, 508, 507, 345, 345, 345, 472, 472, 504, 472, 472, 472, 348, 503, 348, 348, 502, 348,
  348, 348, 473, 473,

  501, 473, 473, 473, 350, 350, 500, 350, 352, 499, 352, 352, 498, 352, 352, 352, 476, 497, 476,
  476, 496, 476, 476, 476, 477, 477, 495, 477, 477, 477, 354, 494, 354, 354, 493, 354, 354, 354,
  478, 478, 492, 478, 478, 478, 117, 117, 491, 117, 117, 117, 482, 482, 482, 436, 436, 490, 436,
  436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 559, 559, 489, 559, 559, 559, 559, 559, 559,
  559, 559, 559, 559, 559, 312, 312, 488, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312,
  442, 442, 487, 442, 442,

  442, 442, 442, 442, 442, 442, 442, 442, 442, 565, 565, 486, 565, 565, 565, 565, 565, 565, 565,
  565, 565, 565, 565, 566, 566, 485, 566, 566, 566, 566, 566, 566, 566, 566, 566, 566, 566, 567,
  567, 484, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 448, 448, 483, 448, 448, 448,
  570, 570, 481, 570, 570, 570, 199, 199, 199, 199, 199, 199, 209, 480, 209, 209, 479, 209, 209,
  209, 461, 447, 461, 461, 446, 461, 461, 461, 329, 329, 443, 329, 329, 329, 462, 462, 332, 462,
  462, 462, 462, 462, 462,

  462, 462, 462, 462, 462, 463, 463, 434, 463, 463, 463, 583, 433, 583, 583, 430, 583, 583, 583,
  215, 429, 215, 215, 428, 215, 215, 215, 469, 427, 469, 469, 426, 469, 469, 469, 338, 338, 425,
  338, 338, 338, 471, 424, 471, 471, 421, 471, 471, 471, 585, 585, 418, 585, 585, 585, 472, 472,
  417, 472, 472, 472, 473, 473, 416, 473, 473, 473, 476, 415, 476, 476, 414, 476, 476, 476, 477,
  477, 413, 477, 477, 477, 478, 478, 412, 478, 478, 478, 117, 117, 411, 117, 117, 117, 589, 589,
  410, 589, 589, 589, 436,

  436, 409, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 436, 559, 559, 408, 559, 559, 559,
  559, 559, 559, 559, 559, 559, 559, 559, 661, 661, 407, 661, 661, 661, 661, 661, 661, 661, 661,
  661, 661, 661, 662, 662, 406, 662, 662, 662, 662, 662, 662, 662, 662, 662, 662, 662, 312, 312,
  405, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 565, 565, 404, 565, 565, 565, 565,
  565, 565, 565, 565, 565, 565, 565, 566, 566, 403, 566, 566, 566, 566, 566, 566, 566, 566, 566,
  566, 566, 567, 567, 402,

  567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 570, 570, 401, 570, 570, 570, 199, 199,
  199, 199, 199, 199, 209, 400, 209, 209, 399, 209, 209, 209, 336, 398, 336, 336, 397, 336, 336,
  336, 583, 396, 583, 583, 395, 583, 583, 583, 463, 463, 394, 463, 463, 463, 215, 393, 215, 215,
  392, 215, 215, 215, 585, 585, 391, 585, 585, 585, 892, 892, 390, 892, 892, 892, 892, 892, 892,
  892, 892, 892, 892, 892, 916, 916, 389, 916, 916, 916, 916, 916, 916, 916, 916, 916, 916, 916,
  719, 719, 719, 719, 719,

  719, 719, 719, 719, 719, 719, 388, 387, 719, 729, 729, 729, 729, 729, 729, 729, 729, 729, 729,
  729, 386, 385, 729, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 384, 383, 781, 787,
  787, 787, 787, 787, 787, 787, 787, 787, 787, 787, 382, 381, 787, 796, 796, 796, 796, 796, 796,
  796, 796, 796, 796, 796, 378, 377, 796, 955, 955, 376, 955, 955, 955, 955, 955, 955, 955, 955,
  955, 955, 955, 964, 964, 375, 964, 964, 964, 964, 964, 964, 964, 964, 964, 964, 964, 872, 872,
  872, 872, 872, 872, 872,

  872, 872, 872, 872, 374, 373, 872, 978, 978, 372, 978, 978, 978, 978, 978, 978, 978, 978, 978,
  978, 978, 979, 979, 371, 979, 979, 979, 979, 979, 979, 979, 979, 979, 979, 979, 370, 369, 366,
  365, 364, 363, 362, 361, 360, 359, 233, 358, 357, 356, 355, 333, 332, 321, 200, 320, 192, 195,
  192, 307, 306, 305, 302, 301, 298, 297, 296, 295, 291, 288, 285, 282, 281, 280, 279, 276, 275,
  274, 273, 272, 269, 268, 265, 264, 263, 257, 256, 255, 254, 253, 252, 251, 250, 240, 239, 238,
  237, 129, 234, 233, 231,

  230, 125, 76, 229, 228, 227, 226, 206, 205, 200, 197, 196, 195, 192, 183, 182, 167, 157, 156, 131,
  126, 125, 119, 118, 114, 85, 76, 66, 980, 3, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980,

  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980 };

static const flex_int16_t yy_chk[2923] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 5, 2, 2, 9, 5, 2,

  10, 11, 10, 10, 13, 13, 17, 13, 13, 16, 2, 19, 22, 13, 30, 22, 19, 13, 25, 25, 17, 17, 11, 29, 2,
  16, 43, 29, 19, 35, 23, 35, 50, 30, 18, 50, 43, 13, 18, 13, 18, 18, 18, 18, 18, 18, 18, 18, 18, 9,
  23, 23, 23, 34, 34, 58, 34, 34, 13, 32, 39, 41, 39, 32, 44, 13, 20, 29, 41, 39, 44, 41, 202, 20,
  41, 20, 20, 20, 20, 20, 20, 20, 20, 20, 40, 21, 45, 80, 202, 40, 20, 45, 21, 20, 21, 21, 21, 21,
  21, 21,

  21, 21, 21, 32, 67, 48, 42, 80, 38, 48, 34, 20, 21, 58, 38, 42, 65, 75, 48, 20, 65, 38, 20, 38,
  48, 42, 49, 38, 49, 49, 84, 54, 52, 52, 53, 54, 38, 53, 76, 55, 20, 21, 52, 52, 55, 63, 53, 76,
  151, 55, 63, 54, 151, 53, 59, 59, 67, 59, 59, 82, 83, 59, 63, 84, 82, 75, 94, 77, 77, 95, 77, 77,
  59, 83, 94, 54, 77, 120, 93, 167, 77, 167, 95, 101, 101, 323, 59, 93, 93, 93, 93, 93, 93, 93, 93,
  93, 146, 146, 165, 54,

  77, 323, 77, 165, 54, 93, 97, 97, 97, 97, 97, 97, 97, 97, 97, 132, 147, 154, 160, 147, 242, 77,
  177, 132, 147, 154, 169, 242, 77, 120, 171, 177, 160, 171, 93, 98, 98, 98, 98, 98, 98, 98, 98, 98,
  169, 99, 171, 180, 203, 180, 195, 195, 99, 98, 99, 99, 99, 99, 99, 99, 99, 99, 99, 189, 100, 305,
  203, 305, 189, 313, 201, 100, 99, 100, 100, 100, 100, 100, 100, 100, 100, 100, 98, 201, 319, 890,
  176, 102, 313, 102, 176, 100, 102, 102, 102, 102, 102, 102, 102, 102,

  102, 99, 104, 104, 104, 104, 104, 104, 104, 104, 104, 321, 105, 127, 127, 321, 127, 127, 891, 105,
  100, 105, 105, 105, 105, 105, 105, 105, 105, 105, 176, 192, 315, 192, 315, 107, 319, 107, 204,
  105, 107, 107, 107, 107, 107, 107, 107, 107, 107, 137, 893, 137, 137, 193, 137, 186, 186, 137,
  186, 186, 310, 193, 186, 137, 197, 137, 137, 137, 105, 197, 127, 194, 194, 186, 204, 294, 308,
  204, 324, 327, 253, 326, 220, 324, 308, 194, 294, 186, 192, 204, 204, 220, 220, 253, 328, 325,
  343, 343, 573, 194,

  207, 207, 207, 207, 207, 207, 207, 207, 207, 296, 322, 573, 383, 208, 383, 326, 414, 310, 296,
  322, 414, 197, 208, 208, 208, 208, 208, 208, 208, 208, 208, 327, 325, 437, 452, 328, 210, 450,
  210, 325, 208, 210, 210, 210, 210, 210, 210, 210, 210, 210, 214, 439, 437, 439, 452, 450, 894,
  895, 671, 214, 214, 214, 214, 214, 214, 214, 214, 214, 451, 208, 722, 440, 722, 216, 451, 216,
  440, 214, 216, 216, 216, 216, 216, 216, 216, 216, 216, 218, 453, 218, 456, 457, 218, 218, 218,
  218, 218, 218, 218, 218,

  218, 454, 671, 897, 571, 898, 214, 219, 219, 219, 219, 219, 219, 219, 219, 219, 221, 221, 221,
  221, 221, 221, 221, 221, 221, 222, 453, 456, 571, 574, 899, 455, 750, 457, 222, 222, 222, 222,
  222, 222, 222, 222, 222, 223, 509, 557, 900, 750, 901, 509, 557, 454, 223, 223, 223, 223, 223,
  223, 223, 223, 223, 576, 902, 225, 668, 574, 223, 223, 223, 223, 223, 223, 225, 225, 225, 225,
  225, 225, 225, 225, 225, 344, 455, 424, 572, 903, 668, 309, 309, 572, 344, 344, 424, 578, 904,
  223, 223, 223, 223, 223,

  223, 309, 330, 330, 330, 330, 330, 330, 330, 330, 330, 331, 669, 576, 755, 309, 757, 749, 825,
  669, 331, 331, 331, 331, 331, 331, 331, 331, 331, 334, 334, 334, 334, 334, 334, 334, 334, 334,
  335, 633, 633, 826, 633, 633, 578, 749, 827, 335, 335, 335, 335, 335, 335, 335, 335, 335, 575,
  672, 755, 905, 757, 337, 825, 337, 828, 335, 337, 337, 337, 337, 337, 337, 337, 337, 337, 339,
  339, 339, 339, 339, 339, 339, 339, 339, 540, 826, 340, 907, 540, 540, 827, 672, 575, 540, 335,
  340, 340, 340, 340, 340,

  340, 340, 340, 340, 342, 674, 713, 713, 828, 713, 713, 864, 865, 342, 342, 342, 342, 342, 342,
  342, 342, 342, 346, 346, 346, 346, 346, 346, 346, 346, 346, 347, 577, 756, 673, 675, 908, 909,
  911, 674, 347, 347, 347, 347, 347, 347, 347, 347, 347, 350, 715, 715, 913, 715, 715, 864, 865,
  914, 350, 350, 350, 350, 350, 350, 350, 350, 350, 756, 577, 353, 673, 675, 350, 350, 350, 350,
  350, 350, 353, 353, 353, 353, 353, 353, 353, 353, 353, 459, 459, 459, 459, 459, 459, 459, 459,
  459, 915, 917, 918, 644,

  919, 350, 350, 350, 350, 350, 350, 351, 644, 644, 842, 842, 920, 842, 842, 921, 351, 351, 351,
  351, 351, 351, 351, 351, 351, 922, 923, 458, 926, 715, 351, 351, 351, 351, 351, 351, 458, 458,
  458, 458, 458, 458, 458, 458, 458, 464, 464, 464, 464, 464, 464, 464, 464, 464, 718, 718, 460,
  718, 718, 351, 351, 351, 351, 351, 351, 460, 460, 460, 460, 460, 460, 460, 460, 460, 465, 927,
  929, 789, 789, 930, 789, 789, 718, 465, 465, 465, 465, 465, 465, 465, 465, 465, 466, 758, 794,
  794, 932, 794, 794, 937,

  938, 466, 466, 466, 466, 466, 466, 466, 466, 466, 467, 467, 467, 467, 467, 467, 467, 467, 467,
  468, 939, 941, 794, 942, 946, 949, 951, 758, 468, 468, 468, 468, 468, 468, 468, 468, 468, 470,
  875, 875, 952, 875, 875, 954, 956, 957, 470, 470, 470, 470, 470, 470, 470, 470, 470, 474, 789,
  960, 961, 963, 965, 966, 967, 969, 474, 474, 474, 474, 474, 474, 474, 474, 474, 970, 971, 579,
  888, 887, 474, 474, 474, 474, 474, 474, 579, 579, 579, 579, 579, 579, 579, 579, 579, 581, 581,
  581, 581, 581, 581, 581,

  581, 581, 751, 751, 886, 751, 751, 474, 474, 474, 474, 474, 474, 475, 885, 751, 884, 875, 883,
  882, 881, 880, 475, 475, 475, 475, 475, 475, 475, 475, 475, 928, 928, 580, 928, 928, 475, 475,
  475, 475, 475, 475, 580, 580, 580, 580, 580, 580, 580, 580, 580, 823, 823, 879, 823, 823, 878,
  945, 945, 928, 945, 945, 582, 877, 823, 475, 475, 475, 475, 475, 475, 582, 582, 582, 582, 582,
  582, 582, 582, 582, 584, 876, 874, 871, 869, 945, 867, 866, 863, 584, 584, 584, 584, 584, 584,
  584, 584, 584, 638, 638,

  638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638,
  638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 638, 670, 670, 862, 670, 670, 676,
  947, 947, 861, 947, 947, 860, 858, 670, 676, 676, 676, 676, 676, 676, 676, 676, 676, 857, 638,
  638, 638, 638, 670, 856, 855, 854, 853, 852, 947, 851, 850, 849, 848, 847, 846, 845, 844, 843,
  841, 838, 836, 835, 670, 834, 833, 832, 831, 830, 638, 638, 638, 638, 645, 645, 645, 645, 645,
  645, 645, 645, 645, 645,

  645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645, 645,
  645, 645, 645, 645, 645, 754, 754, 820, 754, 754, 821, 821, 819, 821, 821, 818, 958, 958, 754,
  958, 958, 968, 968, 821, 968, 968, 817, 816, 815, 645, 645, 645, 645, 754, 814, 813, 812, 811,
  821, 807, 805, 804, 803, 802, 958, 801, 800, 799, 798, 968, 793, 791, 790, 785, 783, 779, 777,
  776, 821, 645, 645, 645, 645, 706, 706, 706, 706, 706, 706, 706, 706, 706, 706, 706, 706, 706,
  706, 706, 706, 706, 706,

  706, 706, 706, 706, 706, 706, 706, 706, 706, 706, 706, 706, 706, 706, 706, 706, 822, 822, 773,
  822, 822, 973, 973, 772, 973, 973, 771, 769, 768, 822, 767, 766, 765, 764, 760, 759, 753, 748,
  747, 746, 706, 706, 706, 706, 822, 745, 744, 743, 742, 973, 741, 739, 738, 737, 735, 734, 732,
  731, 728, 727, 726, 725, 724, 723, 822, 717, 716, 714, 711, 710, 706, 706, 706, 706, 712, 712,
  712, 712, 712, 712, 712, 712, 712, 712, 712, 712, 712, 712, 712, 712, 712, 712, 712, 712, 712,
  712, 712, 712, 712, 712,

  712, 712, 712, 712, 712, 712, 712, 712, 709, 708, 705, 704, 702, 701, 700, 699, 698, 696, 695,
  694, 693, 691, 690, 689, 687, 686, 684, 683, 681, 679, 678, 677, 712, 712, 712, 712, 667, 666,
  665, 664, 663, 660, 659, 658, 656, 655, 654, 653, 652, 651, 650, 649, 648, 647, 643, 642, 641,
  640, 639, 636, 635, 634, 712, 712, 712, 712, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721,
  721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721,
  721, 721, 721, 721, 721,

  632, 631, 630, 629, 628, 626, 625, 624, 623, 619, 618, 615, 614, 613, 612, 611, 610, 607, 606,
  605, 604, 603, 602, 601, 721, 721, 721, 721, 600, 599, 598, 597, 596, 595, 594, 593, 592, 591,
  590, 588, 587, 586, 569, 568, 564, 563, 562, 558, 556, 555, 554, 553, 552, 551, 721, 721, 721,
  721, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840,
  840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 840, 549, 547, 546,
  544, 543, 542, 541, 539,

  538, 537, 536, 535, 533, 532, 531, 530, 529, 528, 526, 525, 524, 523, 522, 521, 840, 840, 840,
  840, 520, 519, 518, 516, 515, 514, 513, 512, 511, 510, 506, 505, 502, 501, 500, 499, 498, 497,
  496, 495, 494, 493, 492, 491, 490, 489, 840, 840, 840, 840, 981, 981, 981, 981, 981, 981, 981,
  981, 981, 981, 981, 981, 981, 981, 982, 982, 982, 982, 982, 982, 488, 982, 982, 982, 982, 982,
  982, 982, 983, 983, 487, 983, 983, 486, 485, 484, 483, 481, 983, 983, 983, 984, 984, 984, 984,
  480, 984, 984, 984, 985,

  985, 479, 985, 985, 985, 986, 986, 447, 986, 986, 986, 986, 986, 986, 986, 986, 986, 986, 986,
  987, 987, 987, 987, 987, 987, 988, 446, 988, 988, 441, 988, 988, 988, 989, 989, 434, 989, 989,
  989, 989, 989, 989, 989, 989, 989, 989, 989, 990, 990, 433, 990, 990, 990, 991, 991, 991, 991,
  432, 991, 991, 991, 992, 992, 431, 992, 993, 993, 430, 993, 993, 993, 994, 428, 427, 426, 994,
  994, 994, 994, 994, 994, 994, 994, 994, 994, 995, 995, 425, 995, 995, 995, 995, 995, 995, 995,
  995, 995, 995, 995, 996,

  996, 996, 997, 997, 423, 997, 997, 997, 998, 422, 998, 998, 421, 998, 998, 998, 999, 999, 420,
  999, 999, 999, 1000, 1000, 419, 1000, 1000, 1000, 1001, 418, 1001, 417, 416, 1001, 1001, 1001,
  1002, 415, 1002, 1002, 413, 1002, 1002, 1002, 1003, 412, 1003, 1003, 411, 1003, 1003, 1003, 1004,
  410, 1004, 1004, 409, 1004, 1004, 1004, 1005, 1005, 408, 1005, 1005, 1005, 1005, 1005, 1005, 1005,
  1005, 1005, 1005, 1005, 1006, 1006, 407, 1006, 1006, 1006, 1006, 1006, 1006, 1006, 1006, 1006,
  1006, 1006, 1007, 1007, 406, 1007, 1007, 1007, 1008, 1008, 1008, 1009, 405, 404,

  403, 402, 401, 1009, 1009, 1009, 1010, 1010, 1010, 1010, 1010, 1010, 1011, 400, 1011, 1011, 398,
  1011, 1011, 1011, 1012, 1012, 397, 1012, 1012, 1012, 1012, 1012, 1012, 1012, 1012, 1012, 1012,
  1012, 1013, 396, 1013, 1013, 395, 1013, 1013, 1013, 1014, 1014, 394, 1014, 1014, 1014, 1015, 1015,
  393, 1015, 1015, 1015, 1016, 391, 1016, 1016, 390, 1016, 1016, 1016, 1017, 1017, 389, 1017, 1017,
  1017, 1018, 388, 1018, 1018, 387, 1018, 1018, 1018, 1019, 386, 1019, 385, 384, 1019, 1019, 1019,
  1020, 1020, 382, 1020, 1020, 1020, 1021, 380, 1021, 1021, 379, 1021, 1021, 1021, 1022, 1022,

  377, 1022, 1022, 1022, 1023, 1023, 376, 1023, 1024, 375, 1024, 1024, 374, 1024, 1024, 1024, 1025,
  373, 1025, 1025, 372, 1025, 1025, 1025, 1026, 1026, 371, 1026, 1026, 1026, 1027, 370, 1027, 1027,
  369, 1027, 1027, 1027, 1028, 1028, 368, 1028, 1028, 1028, 1029, 1029, 367, 1029, 1029, 1029, 1030,
  1030, 1030, 1031, 1031, 366, 1031, 1031, 1031, 1031, 1031, 1031, 1031, 1031, 1031, 1031, 1031,
  1032, 1032, 365, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1033, 1033,
  364, 1033, 1033, 1033, 1033, 1033, 1033, 1033, 1033, 1033, 1033, 1033, 1034, 1034, 363, 1034,
  1034,

  1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1035, 1035, 362, 1035, 1035, 1035, 1035,
  1035, 1035, 1035, 1035, 1035, 1035, 1035, 1036, 1036, 361, 1036, 1036, 1036, 1036, 1036, 1036,
  1036, 1036, 1036, 1036, 1036, 1037, 1037, 360, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037,
  1037, 1037, 1037, 1038, 1038, 359, 1038, 1038, 1038, 1039, 1039, 357, 1039, 1039, 1039, 1040,
  1040, 1040, 1040, 1040, 1040, 1041, 356, 1041, 1041, 355, 1041, 1041, 1041, 1042, 317, 1042, 1042,
  316, 1042, 1042, 1042, 1043, 1043, 314, 1043, 1043, 1043, 1044, 1044, 311, 1044, 1044, 1044, 1044,
  1044, 1044,

  1044, 1044, 1044, 1044, 1044, 1045, 1045, 307, 1045, 1045, 1045, 1046, 306, 1046, 1046, 304, 1046,
  1046, 1046, 1047, 303, 1047, 1047, 302, 1047, 1047, 1047, 1048, 301, 1048, 1048, 300, 1048, 1048,
  1048, 1049, 1049, 299, 1049, 1049, 1049, 1050, 298, 1050, 1050, 295, 1050, 1050, 1050, 1051, 1051,
  293, 1051, 1051, 1051, 1052, 1052, 292, 1052, 1052, 1052, 1053, 1053, 291, 1053, 1053, 1053, 1054,
  290, 1054, 1054, 289, 1054, 1054, 1054, 1055, 1055, 288, 1055, 1055, 1055, 1056, 1056, 287, 1056,
  1056, 1056, 1057, 1057, 286, 1057, 1057, 1057, 1058, 1058, 285, 1058, 1058, 1058, 1059,

  1059, 284, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1059, 1060, 1060, 283,
  1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1060, 1061, 1061, 282, 1061, 1061,
  1061, 1061, 1061, 1061, 1061, 1061, 1061, 1061, 1061, 1062, 1062, 281, 1062, 1062, 1062, 1062,
  1062, 1062, 1062, 1062, 1062, 1062, 1062, 1063, 1063, 280, 1063, 1063, 1063, 1063, 1063, 1063,
  1063, 1063, 1063, 1063, 1063, 1064, 1064, 279, 1064, 1064, 1064, 1064, 1064, 1064, 1064, 1064,
  1064, 1064, 1064, 1065, 1065, 278, 1065, 1065, 1065, 1065, 1065, 1065, 1065, 1065, 1065, 1065,
  1065, 1066, 1066, 277,

  1066, 1066, 1066, 1066, 1066, 1066, 1066, 1066, 1066, 1066, 1066, 1067, 1067, 275, 1067, 1067,
  1067, 1068, 1068, 1068, 1068, 1068, 1068, 1069, 274, 1069, 1069, 273, 1069, 1069, 1069, 1070, 272,
  1070, 1070, 270, 1070, 1070, 1070, 1071, 269, 1071, 1071, 268, 1071, 1071, 1071, 1072, 1072, 267,
  1072, 1072, 1072, 1073, 266, 1073, 1073, 265, 1073, 1073, 1073, 1074, 1074, 264, 1074, 1074, 1074,
  1075, 1075, 263, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1075, 1076, 1076,
  262, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1076, 1077, 1077, 1077, 1077,
  1077,

  1077, 1077, 1077, 1077, 1077, 1077, 261, 260, 1077, 1078, 1078, 1078, 1078, 1078, 1078, 1078,
  1078, 1078, 1078, 1078, 259, 258, 1078, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079, 1079,
  1079, 1079, 257, 256, 1079, 1080, 1080, 1080, 1080, 1080, 1080, 1080, 1080, 1080, 1080, 1080, 255,
  254, 1080, 1081, 1081, 1081, 1081, 1081, 1081, 1081, 1081, 1081, 1081, 1081, 252, 251, 1081, 1082,
  1082, 250, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1082, 1083, 1083, 249,
  1083, 1083, 1083, 1083, 1083, 1083, 1083, 1083, 1083, 1083, 1083, 1084, 1084, 1084, 1084, 1084,
  1084, 1084,

  1084, 1084, 1084, 1084, 248, 247, 1084, 1085, 1085, 246, 1085, 1085, 1085, 1085, 1085, 1085, 1085,
  1085, 1085, 1085, 1085, 1086, 1086, 245, 1086, 1086, 1086, 1086, 1086, 1086, 1086, 1086, 1086,
  1086, 1086, 244, 243, 241, 240, 239, 238, 237, 236, 235, 234, 232, 231, 230, 229, 228, 213, 211,
  200, 199, 198, 191, 190, 188, 183, 182, 181, 179, 178, 175, 174, 173, 172, 170, 168, 166, 164,
  163, 162, 161, 159, 158, 157, 156, 155, 153, 152, 150, 149, 148, 145, 144, 143, 142, 141, 140,
  139, 138, 136, 135, 134, 133, 130, 126, 125, 124,

  123, 122, 121, 119, 118, 116, 112, 92, 90, 81, 69, 68, 64, 62, 57, 56, 51, 47, 46, 37, 33, 31, 28,
  26, 24, 15, 12, 8, 3, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,

  980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,
  980, 980, 980 };

/* Table of booleans, true if rule could match eol. */
static const flex_int32_t yy_rule_can_match_eol[167] = {
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
};

static yy_state_type yy_last_accepting_state;
static char* yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char* yytext;

/*

This file must be translated to C and modified to build everywhere.

See the adjacent README.txt file for instructions.

*/

/* to workaround https://bugs.llvm.org/show_bug.cgi?id=43465 */
#if defined(__clang__)
#pragma clang diagnostic push
#if defined(__has_warning)
#if __has_warning("-Wimplicit-fallthrough")
#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#endif
#endif
#elif defined(__GNUC__) && (__GNUC__ >= 7)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
#endif

/* We do not care of interactive mode */
#define YY_NEVER_INTERACTIVE 1

/* Do not include unistd.h in generated source. */
#define YY_NO_UNISTD_H

/* Skip declaring this function.  It is a macro.  */
#define YY_SKIP_YYWRAP

#ifdef _WIN32
#pragma warning(disable : 4018)
#pragma warning(disable : 4127)
#pragma warning(disable : 4131)
#pragma warning(disable : 4244)
#pragma warning(disable : 4251)
#pragma warning(disable : 4267)
#pragma warning(disable : 4305)
#pragma warning(disable : 4309)
#pragma warning(disable : 4706)
#pragma warning(disable : 4786)
#endif

#define SKIP_MATCH_MAXLEN 15

/*
 * Skip ahead until one of the strings is found,
 * then skip to the end of the line.
 * Return 0 if no match found.
 */
static int skip_comment(void);
static int skip_trailing_comment(const char* text, size_t l);
static int skip_ahead_multi(const char* strings[]);
static int skip_ahead_until(const char* text);
static int skip_to_next_directive(void);
static int skip_conditional_block(void);

static void doxygen_comment(void);
static void doxygen_cpp_comment(void);
static void doxygen_group_start(void);
static void doxygen_group_end(void);
static void vtk_comment(void);
static void vtk_name_comment(void);
static void vtk_section_comment(void);
static void cpp_comment_line(void);
static void blank_line(void);

static const char* raw_string(const char* begin);

static void preprocessor_directive(const char* text, size_t l);
static void print_preprocessor_error(int result, const char* cp, size_t n);
static char* get_macro_arguments(void);

static void push_buffer(void);
static int pop_buffer(void);

static void push_include(const char* filename);
static void pop_include(void);

static void push_macro(MacroInfo* macro);
static void pop_macro(void);
static int in_macro(void);

#define INITIAL 0

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void*
#endif

static int yy_init_globals(void);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy(void);

int yyget_debug(void);

void yyset_debug(int debug_flag);

YY_EXTRA_TYPE yyget_extra(void);

void yyset_extra(YY_EXTRA_TYPE user_defined);

FILE* yyget_in(void);

void yyset_in(FILE* _in_str);

FILE* yyget_out(void);

void yyset_out(FILE* _out_str);

int yyget_leng(void);

char* yyget_text(void);

int yyget_lineno(void);

void yyset_lineno(int _line_number);

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap(void);
#else
extern int yywrap(void);
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput(int c, char* buf_ptr);

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy(char*, const char*, int);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char*);
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput(void);
#else
static int input(void);
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO                                                                                       \
  do                                                                                               \
  {                                                                                                \
    if (fwrite(yytext, (size_t)yyleng, 1, yyout))                                                  \
    {                                                                                              \
    }                                                                                              \
  } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)                                                            \
  if (YY_CURRENT_BUFFER_LVALUE->yy_is_interactive)                                                 \
  {                                                                                                \
    int c = '*';                                                                                   \
    int n;                                                                                         \
    for (n = 0; n < max_size && (c = getc(yyin)) != EOF && c != '\n'; ++n)                         \
      buf[n] = (char)c;                                                                            \
    if (c == '\n')                                                                                 \
      buf[n++] = (char)c;                                                                          \
    if (c == EOF && ferror(yyin))                                                                  \
      YY_FATAL_ERROR("input in flex scanner failed");                                              \
    result = n;                                                                                    \
  }                                                                                                \
  else                                                                                             \
  {                                                                                                \
    errno = 0;                                                                                     \
    while ((result = (int)fread(buf, 1, (yy_size_t)max_size, yyin)) == 0 && ferror(yyin))          \
    {                                                                                              \
      if (errno != EINTR)                                                                          \
      {                                                                                            \
        YY_FATAL_ERROR("input in flex scanner failed");                                            \
        break;                                                                                     \
      }                                                                                            \
      errno = 0;                                                                                   \
      clearerr(yyin);                                                                              \
    }                                                                                              \
  }

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error(msg)
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex(void);

#define YY_DECL int yylex(void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/ break;
#endif

#define YY_RULE_SETUP                                                                              \
  if (yyleng > 0)                                                                                  \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (yytext[yyleng - 1] == '\n');                            \
  YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
  yy_state_type yy_current_state;
  char *yy_cp, *yy_bp;
  int yy_act;

  if (!(yy_init))
  {
    (yy_init) = 1;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if (!(yy_start))
      (yy_start) = 1; /* first start state */

    if (!yyin)
      yyin = stdin;

    if (!yyout)
      yyout = stdout;

    if (!YY_CURRENT_BUFFER)
    {
      yyensure_buffer_stack();
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
    }

    yy_load_buffer_state();
  }

  {

    while (/*CONSTCOND*/ 1) /* loops until end-of-file is reached */
    {
      yy_cp = (yy_c_buf_p);

      /* Support of yytext. */
      *yy_cp = (yy_hold_char);

      /* yy_bp points to the position in yy_ch_buf of the start of
       * the current run.
       */
      yy_bp = yy_cp;

      yy_current_state = (yy_start);
      yy_current_state += YY_AT_BOL();
    yy_match:
      do
      {
        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
        if (yy_accept[yy_current_state])
        {
          (yy_last_accepting_state) = yy_current_state;
          (yy_last_accepting_cpos) = yy_cp;
        }
        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
        {
          yy_current_state = (int)yy_def[yy_current_state];
          if (yy_current_state >= 981)
            yy_c = yy_meta[yy_c];
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
        ++yy_cp;
      } while (yy_base[yy_current_state] != 2830);

    yy_find_action:
      yy_act = yy_accept[yy_current_state];
      if (yy_act == 0)
      { /* have to back up */
        yy_cp = (yy_last_accepting_cpos);
        yy_current_state = (yy_last_accepting_state);
        yy_act = yy_accept[yy_current_state];
      }

      YY_DO_BEFORE_ACTION;

      if (yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act])
      {
        int yyl;
        for (yyl = 0; yyl < yyleng; ++yyl)
          if (yytext[yyl] == '\n')

            yylineno++;
        ;
      }

    do_action: /* This label is used only to access EOF actions. */

      switch (yy_act)
      {         /* beginning of action switch */
        case 0: /* must back up */
          /* undo the effects of YY_DO_BEFORE_ACTION */
          *yy_cp = (yy_hold_char);
          yy_cp = (yy_last_accepting_cpos);
          yy_current_state = (yy_last_accepting_state);
          goto yy_find_action;

        case 1:
          YY_RULE_SETUP { doxygen_comment(); }
          YY_BREAK
        case 2:
          YY_RULE_SETUP { doxygen_comment(); }
          YY_BREAK
        case 3:
          YY_RULE_SETUP { skip_comment(); }
          YY_BREAK
        case 4:
          YY_RULE_SETUP { skip_ahead_until("@end"); }
          YY_BREAK
        case 5:
          YY_RULE_SETUP { doxygen_cpp_comment(); }
          YY_BREAK
        case 6:
          YY_RULE_SETUP { doxygen_cpp_comment(); }
          YY_BREAK
        case 7:
          YY_RULE_SETUP { doxygen_group_start(); }
          YY_BREAK
        case 8:
          YY_RULE_SETUP { doxygen_group_end(); }
          YY_BREAK
        case 9:
          YY_RULE_SETUP { vtk_comment(); }
          YY_BREAK
        case 10:
          YY_RULE_SETUP { vtk_name_comment(); }
          YY_BREAK
        case 11:
          YY_RULE_SETUP { vtk_section_comment(); }
          YY_BREAK
        case 12:
          YY_RULE_SETUP { cpp_comment_line(); }
          YY_BREAK
        case 13:
          /* rule 13 can match eol */
          YY_RULE_SETUP { blank_line(); }
          YY_BREAK
        case 14:
          YY_RULE_SETUP
          /* eat trailing C++ comments */
          YY_BREAK
        case 15:
          /* rule 15 can match eol */
          YY_RULE_SETUP
          {
            skip_trailing_comment(yytext, yyleng);
            preprocessor_directive(yytext, yyleng);
          }
          YY_BREAK
        case 16:
          /* rule 16 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (STRING_LITERAL);
          }
          YY_BREAK
        case 17:
          /* rule 17 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (CHAR_LITERAL);
          }
          YY_BREAK
        case 18:
          YY_RULE_SETUP
          {
            yylval.str = raw_string(yytext);
            return (STRING_LITERAL);
          }
          YY_BREAK
        case 19:
          YY_RULE_SETUP
          return (AUTO);
          YY_BREAK
        case 20:
          YY_RULE_SETUP
          return (DOUBLE);
          YY_BREAK
        case 21:
          YY_RULE_SETUP
          return (FLOAT);
          YY_BREAK
        case 22:
          YY_RULE_SETUP
          return (INT64__);
          YY_BREAK
        case 23:
          YY_RULE_SETUP
          return (SHORT);
          YY_BREAK
        case 24:
          YY_RULE_SETUP
          return (LONG);
          YY_BREAK
        case 25:
          YY_RULE_SETUP
          return (CHAR);
          YY_BREAK
        case 26:
          YY_RULE_SETUP
          return (INT);
          YY_BREAK
        case 27:
          YY_RULE_SETUP
          return (UNSIGNED);
          YY_BREAK
        case 28:
          YY_RULE_SETUP
          return (SIGNED);
          YY_BREAK
        case 29:
          YY_RULE_SETUP
          return (VOID);
          YY_BREAK
        case 30:
          YY_RULE_SETUP
          return (BOOL);
          YY_BREAK
        case 31:
          YY_RULE_SETUP
          return (CHAR16_T);
          YY_BREAK
        case 32:
          YY_RULE_SETUP
          return (CHAR32_T);
          YY_BREAK
        case 33:
          YY_RULE_SETUP
          return (WCHAR_T);
          YY_BREAK
        case 34:
          /* rule 34 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = (yytext[3] == ':' ? "std::size_t" : "size_t");
            return (SIZE_T);
          }
          YY_BREAK
        case 35:
          /* rule 35 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = (yytext[3] == ':' ? "std::ssize_t" : "ssize_t");
            return (SSIZE_T);
          }
          YY_BREAK
        case 36:
          /* rule 36 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = (yytext[3] == ':' ? "std::nullptr_t" : "nullptr_t");
            return (NULLPTR_T);
          }
          YY_BREAK
        case 37:
          YY_RULE_SETUP
          /* ignore the Q_OBJECT macro from Qt */
          YY_BREAK
        case 38:
          /* rule 38 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PUBLIC);
          YY_BREAK
        case 39:
          /* rule 39 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PRIVATE);
          YY_BREAK
        case 40:
          /* rule 40 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PROTECTED);
          YY_BREAK
        case 41:
          /* rule 41 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (PROTECTED);
          YY_BREAK
        case 42:
          YY_RULE_SETUP
          return (CLASS);
          YY_BREAK
        case 43:
          YY_RULE_SETUP
          return (STRUCT);
          YY_BREAK
        case 44:
          YY_RULE_SETUP
          return (PUBLIC);
          YY_BREAK
        case 45:
          YY_RULE_SETUP
          return (PRIVATE);
          YY_BREAK
        case 46:
          YY_RULE_SETUP
          return (PROTECTED);
          YY_BREAK
        case 47:
          YY_RULE_SETUP
          return (ENUM);
          YY_BREAK
        case 48:
          YY_RULE_SETUP
          return (UNION);
          YY_BREAK
        case 49:
          YY_RULE_SETUP
          return (VIRTUAL);
          YY_BREAK
        case 50:
          YY_RULE_SETUP
          return (CONST);
          YY_BREAK
        case 51:
          YY_RULE_SETUP
          return (VOLATILE);
          YY_BREAK
        case 52:
          YY_RULE_SETUP
          return (MUTABLE);
          YY_BREAK
        case 53:
          YY_RULE_SETUP
          return (OPERATOR);
          YY_BREAK
        case 54:
          YY_RULE_SETUP
          return (FRIEND);
          YY_BREAK
        case 55:
          YY_RULE_SETUP
          return (INLINE);
          YY_BREAK
        case 56:
          YY_RULE_SETUP
          return (CONSTEXPR);
          YY_BREAK
        case 57:
          YY_RULE_SETUP
          return (STATIC);
          YY_BREAK
        case 58:
          YY_RULE_SETUP
          return (THREAD_LOCAL);
          YY_BREAK
        case 59:
          YY_RULE_SETUP
          return (EXTERN);
          YY_BREAK
        case 60:
          YY_RULE_SETUP
          return (TEMPLATE);
          YY_BREAK
        case 61:
          YY_RULE_SETUP
          return (TYPENAME);
          YY_BREAK
        case 62:
          YY_RULE_SETUP
          return (TYPEDEF);
          YY_BREAK
        case 63:
          YY_RULE_SETUP
          return (NAMESPACE);
          YY_BREAK
        case 64:
          YY_RULE_SETUP
          return (USING);
          YY_BREAK
        case 65:
          YY_RULE_SETUP
          return (NEW);
          YY_BREAK
        case 66:
          YY_RULE_SETUP
          return (DELETE);
          YY_BREAK
        case 67:
          YY_RULE_SETUP
          return (EXPLICIT);
          YY_BREAK
        case 68:
          YY_RULE_SETUP
          return (THROW);
          YY_BREAK
        case 69:
          YY_RULE_SETUP
          return (TRY);
          YY_BREAK
        case 70:
          YY_RULE_SETUP
          return (CATCH);
          YY_BREAK
        case 71:
          YY_RULE_SETUP
          return (NOEXCEPT);
          YY_BREAK
        case 72:
          YY_RULE_SETUP
          return (DECLTYPE);
          YY_BREAK
        case 73:
          YY_RULE_SETUP
          return (DEFAULT);
          YY_BREAK
        case 74:
          YY_RULE_SETUP
          return (STATIC_CAST);
          YY_BREAK
        case 75:
          YY_RULE_SETUP
          return (DYNAMIC_CAST);
          YY_BREAK
        case 76:
          YY_RULE_SETUP
          return (CONST_CAST);
          YY_BREAK
        case 77:
          YY_RULE_SETUP
          return (REINTERPRET_CAST);
          YY_BREAK
        case 78:
          YY_RULE_SETUP
          /* irrelevant to wrappers */
          YY_BREAK
        case 79:
          YY_RULE_SETUP
          return (OP_LOGIC_AND);
          YY_BREAK
        case 80:
          YY_RULE_SETUP
          return (OP_AND_EQ);
          YY_BREAK
        case 81:
          YY_RULE_SETUP
          return (OP_LOGIC_OR);
          YY_BREAK
        case 82:
          YY_RULE_SETUP
          return (OP_OR_EQ);
          YY_BREAK
        case 83:
          YY_RULE_SETUP
          return ('!');
          YY_BREAK
        case 84:
          YY_RULE_SETUP
          return (OP_LOGIC_NEQ);
          YY_BREAK
        case 85:
          YY_RULE_SETUP
          return ('^');
          YY_BREAK
        case 86:
          YY_RULE_SETUP
          return (OP_XOR_EQ);
          YY_BREAK
        case 87:
          YY_RULE_SETUP
          return ('&');
          YY_BREAK
        case 88:
          YY_RULE_SETUP
          return ('|');
          YY_BREAK
        case 89:
          YY_RULE_SETUP
          return ('~');
          YY_BREAK
        case 90:
          /* rule 90 can match eol */
          YY_RULE_SETUP
          {
            size_t i = 1;
            size_t j;
            while (yytext[i] == ' ' || yytext[i] == '\t' || yytext[i] == '\r' || yytext[i] == '\n')
            {
              i++;
            }
            j = i;
            while (yytext[j] != '&')
            {
              j++;
            }
            yylval.str = vtkstrndup(&yytext[i], j - i);
            return (LA);
          }
          YY_BREAK
        case 91:
          /* rule 91 can match eol */
          YY_RULE_SETUP
          {
            size_t i = 1;
            size_t j;
            while (yytext[i] == ' ' || yytext[i] == '\t' || yytext[i] == '\r' || yytext[i] == '\n')
            {
              i++;
            }
            j = i;
            while (yytext[j] != '*')
            {
              j++;
            }
            yylval.str = vtkstrndup(&yytext[i], j - i);
            return (LP);
          }
          YY_BREAK
        case 92:
          /* rule 92 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = "";
            return (LP);
          }
          YY_BREAK
        case 93:
          /* rule 93 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = "";
            return (LP);
          }
          YY_BREAK
        case 94:
          /* rule 94 can match eol */
          YY_RULE_SETUP
          {
            yylval.str = "";
            return (LP);
          }
          YY_BREAK
        case 95:
          YY_RULE_SETUP
          return ('*');
          YY_BREAK
        case 96:
          YY_RULE_SETUP
          /* misc unused win32 macros */
          YY_BREAK
        case 97:
          /* rule 97 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (OSTREAM);
          }
          YY_BREAK
        case 98:
          /* rule 98 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (ISTREAM);
          }
          YY_BREAK
        case 99:
          /* rule 99 can match eol */
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          YY_LINENO_REWIND_TO(yy_cp - 1);
          (yy_c_buf_p) = yy_cp -= 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (StdString);
          }
          YY_BREAK
        case 100:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (StdString);
          }
          YY_BREAK
        case 101:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (UnicodeString);
          }
          YY_BREAK
        case 102:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (QT_ID);
          }
          YY_BREAK
        case 103:
          YY_RULE_SETUP
          get_macro_arguments(); /* C++11 */
          YY_BREAK
        case 104:
          YY_RULE_SETUP
          get_macro_arguments(); /* C++11 */
          YY_BREAK
        case 105:
          YY_RULE_SETUP
          get_macro_arguments(); /* C11 */
          YY_BREAK
        case 106:
          YY_RULE_SETUP
          get_macro_arguments(); /* C11 */
          YY_BREAK
        case 107:
          YY_RULE_SETUP
          return (THREAD_LOCAL); /* C11 */
          YY_BREAK
        case 108:
          YY_RULE_SETUP
          /* C11 */
          YY_BREAK
        case 109:
          YY_RULE_SETUP
          /* C11 */
          YY_BREAK
        case 110:
          YY_RULE_SETUP
          get_macro_arguments(); /* C99 */
          YY_BREAK
        case 111:
          YY_RULE_SETUP
          get_macro_arguments(); /* MSVC */
          YY_BREAK
        case 112:
          YY_RULE_SETUP
          get_macro_arguments(); /* gcc attributes */
          YY_BREAK
        case 113:
          YY_RULE_SETUP
          get_macro_arguments(); /* Windows linkage */
          YY_BREAK
        case 114:
          YY_RULE_SETUP
          /* Windows */
          YY_BREAK
        case 115:
          YY_RULE_SETUP
          /* gcc/clang/other extension */
          YY_BREAK
        case 116:
          YY_RULE_SETUP
          /* MSVC extension */
          YY_BREAK
        case 117:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (NULLPTR);
          }
          YY_BREAK
        case 118:
          YY_RULE_SETUP
          {
            const char* name = vtkstrndup(yytext, yyleng);
            MacroInfo* macro = vtkParsePreprocess_GetMacro(preprocessor, name);
            int expanded = 0;
            if (macro)
            {
              char* args = NULL;
              const char* emacro = NULL;

              if (macro->IsFunction)
              {
                args = get_macro_arguments();
                if (args)
                {
                  emacro = vtkParsePreprocess_ExpandMacro(preprocessor, macro, args);
                  if (!emacro)
                  {
                    print_preprocessor_error(VTK_PARSE_MACRO_NUMARGS, NULL, 0);
                    exit(1);
                  }
                  free(args);
                }
              }
              else if (macro->Definition && macro->Definition[0])
              {
                /* first see if macro evaluates to a constant value */
                preproc_int_t val;
                int is_unsigned;
                int r;
                macro->IsExcluded = 1;
                r = vtkParsePreprocess_EvaluateExpression(
                  preprocessor, macro->Definition, &val, &is_unsigned);
                macro->IsExcluded = 0;
                /* if it isn't a constant expression, then expand it */
                if (r >= VTK_PARSE_MACRO_UNDEFINED)
                {
                  emacro = vtkParsePreprocess_ExpandMacro(preprocessor, macro, NULL);
                  if (!emacro)
                  {
                    print_preprocessor_error(r, NULL, 0);
                    exit(1);
                  }
                }
              }
              else
              {
                /* macros with no definition expand to nothing */
                expanded = 1;
              }
              if (emacro)
              {
                /* invoke the parser on any expanded macros */
                push_macro(macro);
                push_buffer();
                yy_switch_to_buffer(yy_scan_string(emacro));
                vtkParsePreprocess_FreeMacroExpansion(preprocessor, macro, emacro);
                expanded = 1;
              }
            }
            if (!expanded)
            {
              /* if no macro expansion occurred, return the ID */
              yylval.str = name;
              if (yyleng > 3 && name[0] == 'v' && name[1] == 't' && name[2] == 'k')
              {
                return (VTK_ID);
              }
              else if (name[0] == 'Q')
              {
                return (QT_ID);
              }
              else
              {
                return (ID);
              }
            }
          }
          YY_BREAK
        case 119:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 120:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 121:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 122:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (FLOAT_LITERAL);
          }
          YY_BREAK
        case 123:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (HEX_LITERAL);
          }
          YY_BREAK
        case 124:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (BIN_LITERAL);
          }
          YY_BREAK
        case 125:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (OCT_LITERAL);
          }
          YY_BREAK
        case 126:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (INT_LITERAL);
          }
          YY_BREAK
        case 127:
          YY_RULE_SETUP
          {
            yylval.str = vtkstrndup(yytext, yyleng);
            return (ZERO);
          }
          YY_BREAK
        case 128:
          /* rule 128 can match eol */
          YY_RULE_SETUP
          /* escaped newlines */
          YY_BREAK
        case 129:
          YY_RULE_SETUP
          /* whitespace */
          YY_BREAK
        case 130:
          /* rule 130 can match eol */
          YY_RULE_SETUP
          /* whitespace */
          YY_BREAK
        case 131:
          /* rule 131 can match eol */
          YY_RULE_SETUP
          return (BEGIN_ATTRIB);
          YY_BREAK
        case 132:
          YY_RULE_SETUP
          return ('{');
          YY_BREAK
        case 133:
          YY_RULE_SETUP
          return ('}');
          YY_BREAK
        case 134:
          YY_RULE_SETUP
          return ('[');
          YY_BREAK
        case 135:
          YY_RULE_SETUP
          return (']');
          YY_BREAK
        case 136:
          YY_RULE_SETUP
          return ('#');
          YY_BREAK
        case 137:
          *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */
          (yy_c_buf_p) = yy_cp = yy_bp + 1;
          YY_DO_BEFORE_ACTION; /* set up yytext again */
          YY_RULE_SETUP
          return (OP_RSHIFT_A);
          YY_BREAK
        case 138:
          YY_RULE_SETUP
          return (OP_LSHIFT_EQ);
          YY_BREAK
        case 139:
          YY_RULE_SETUP
          return (OP_RSHIFT_EQ);
          YY_BREAK
        case 140:
          YY_RULE_SETUP
          return (OP_LSHIFT);
          YY_BREAK
        case 141:
          YY_RULE_SETUP
          return (OP_DOT_POINTER);
          YY_BREAK
        case 142:
          YY_RULE_SETUP
          return (OP_ARROW_POINTER);
          YY_BREAK
        case 143:
          YY_RULE_SETUP
          return (OP_ARROW);
          YY_BREAK
        case 144:
          YY_RULE_SETUP
          return (OP_INCR);
          YY_BREAK
        case 145:
          YY_RULE_SETUP
          return (OP_DECR);
          YY_BREAK
        case 146:
          YY_RULE_SETUP
          return (OP_PLUS_EQ);
          YY_BREAK
        case 147:
          YY_RULE_SETUP
          return (OP_MINUS_EQ);
          YY_BREAK
        case 148:
          YY_RULE_SETUP
          return (OP_TIMES_EQ);
          YY_BREAK
        case 149:
          YY_RULE_SETUP
          return (OP_DIVIDE_EQ);
          YY_BREAK
        case 150:
          YY_RULE_SETUP
          return (OP_REMAINDER_EQ);
          YY_BREAK
        case 151:
          YY_RULE_SETUP
          return (OP_AND_EQ);
          YY_BREAK
        case 152:
          YY_RULE_SETUP
          return (OP_OR_EQ);
          YY_BREAK
        case 153:
          YY_RULE_SETUP
          return (OP_XOR_EQ);
          YY_BREAK
        case 154:
          YY_RULE_SETUP
          return (OP_LOGIC_AND);
          YY_BREAK
        case 155:
          YY_RULE_SETUP
          return (OP_LOGIC_OR);
          YY_BREAK
        case 156:
          YY_RULE_SETUP
          return (OP_LOGIC_EQ);
          YY_BREAK
        case 157:
          YY_RULE_SETUP
          return (OP_LOGIC_NEQ);
          YY_BREAK
        case 158:
          YY_RULE_SETUP
          return (OP_LOGIC_LEQ);
          YY_BREAK
        case 159:
          YY_RULE_SETUP
          return (OP_LOGIC_GEQ);
          YY_BREAK
        case 160:
          YY_RULE_SETUP
          return (ELLIPSIS);
          YY_BREAK
        case 161:
          YY_RULE_SETUP
          return (DOUBLE_COLON);
          YY_BREAK
        case 162:
          YY_RULE_SETUP
          return ('[');
          YY_BREAK
        case 163:
          YY_RULE_SETUP
          return (']');
          YY_BREAK
        case 164:
          YY_RULE_SETUP
          return (yytext[0]);
          YY_BREAK
        case YY_STATE_EOF(INITIAL):
        {
          if (!pop_buffer())
          {
            yyterminate();
          }
        }
          YY_BREAK
        case 165:
          YY_RULE_SETUP { return (OTHER); }
          YY_BREAK
        case 166:
          YY_RULE_SETUP
          YY_FATAL_ERROR("flex scanner jammed");
          YY_BREAK

        case YY_END_OF_BUFFER:
        {
          /* Amount of text matched not including the EOB char. */
          int yy_amount_of_matched_text = (int)(yy_cp - (yytext_ptr)) - 1;

          /* Undo the effects of YY_DO_BEFORE_ACTION. */
          *yy_cp = (yy_hold_char);
          YY_RESTORE_YY_MORE_OFFSET

          if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW)
          {
            /* We're scanning a new file or input source.  It's
             * possible that this happened because the user
             * just pointed yyin at a new source and called
             * yylex().  If so, then we have to assure
             * consistency between YY_CURRENT_BUFFER and our
             * globals.  Here is the right place to do so, because
             * this is the first action (other than possibly a
             * back-up) that will match for the new input source.
             */
            (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
            YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
            YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
          }

          /* Note that here we test for yy_c_buf_p "<=" to the position
           * of the first EOB in the buffer, since yy_c_buf_p will
           * already have been incremented past the NUL character
           * (since all states make transitions on EOB to the
           * end-of-buffer state).  Contrast this with the test
           * in input().
           */
          if ((yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
          { /* This was really a NUL. */
            yy_state_type yy_next_state;

            (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

            yy_current_state = yy_get_previous_state();

            /* Okay, we're now positioned to make the NUL
             * transition.  We couldn't have
             * yy_get_previous_state() go ahead and do it
             * for us because it doesn't know how to deal
             * with the possibility of jamming (and we don't
             * want to build jamming into it because then it
             * will run more slowly).
             */

            yy_next_state = yy_try_NUL_trans(yy_current_state);

            yy_bp = (yytext_ptr) + YY_MORE_ADJ;

            if (yy_next_state)
            {
              /* Consume the NUL. */
              yy_cp = ++(yy_c_buf_p);
              yy_current_state = yy_next_state;
              goto yy_match;
            }

            else
            {
              yy_cp = (yy_c_buf_p);
              goto yy_find_action;
            }
          }

          else
            switch (yy_get_next_buffer())
            {
              case EOB_ACT_END_OF_FILE:
              {
                (yy_did_buffer_switch_on_eof) = 0;

                if (yywrap())
                {
                  /* Note: because we've taken care in
                   * yy_get_next_buffer() to have set up
                   * yytext, we can now set up
                   * yy_c_buf_p so that if some total
                   * hoser (like flex itself) wants to
                   * call the scanner after we return the
                   * YY_NULL, it'll still work - another
                   * YY_NULL will get returned.
                   */
                  (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

                  yy_act = YY_STATE_EOF(YY_START);
                  goto do_action;
                }

                else
                {
                  if (!(yy_did_buffer_switch_on_eof))
                    YY_NEW_FILE;
                }
                break;
              }

              case EOB_ACT_CONTINUE_SCAN:
                (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state();

                yy_cp = (yy_c_buf_p);
                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                goto yy_match;

              case EOB_ACT_LAST_MATCH:
                (yy_c_buf_p) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

                yy_current_state = yy_get_previous_state();

                yy_cp = (yy_c_buf_p);
                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                goto yy_find_action;
            }
          break;
        }

        default:
          YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
      } /* end of action switch */
    }   /* end of scanning one token */
  }     /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *  EOB_ACT_LAST_MATCH -
 *  EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *  EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer(void)
{
  char* dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char* source = (yytext_ptr);
  int number_to_move, i;
  int ret_val;

  if ((yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1])
    YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");

  if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0)
  { /* Don't try to fill the buffer, so this is an EOF. */
    if ((yy_c_buf_p) - (yytext_ptr)-YY_MORE_ADJ == 1)
    {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
    }

    else
    {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
    }
  }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int)((yy_c_buf_p) - (yytext_ptr)-1);

  for (i = 0; i < number_to_move; ++i)
    *(dest++) = *(source++);

  if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

  else
  {
    int num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while (num_to_read <= 0)
    { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

      int yy_c_buf_p_offset = (int)((yy_c_buf_p)-b->yy_ch_buf);

      if (b->yy_is_our_buffer)
      {
        int new_size = b->yy_buf_size * 2;

        if (new_size <= 0)
          b->yy_buf_size += b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char*)
          /* Include room in for 2 EOB chars. */
          yyrealloc((void*)b->yy_ch_buf, (yy_size_t)(b->yy_buf_size + 2));
      }
      else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = NULL;

      if (!b->yy_ch_buf)
        YY_FATAL_ERROR("fatal error - scanner input buffer overflow");

      (yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

      num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
    }

    if (num_to_read > YY_READ_BUF_SIZE)
      num_to_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]), (yy_n_chars), num_to_read);

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  if ((yy_n_chars) == 0)
  {
    if (number_to_move == YY_MORE_ADJ)
    {
      ret_val = EOB_ACT_END_OF_FILE;
      yyrestart(yyin);
    }

    else
    {
      ret_val = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
    }
  }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size)
  {
    /* Extend the array by 50%, plus the number we really need. */
    int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf =
      (char*)yyrealloc((void*)YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t)new_size);
    if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      YY_FATAL_ERROR("out of dynamic memory in yy_get_next_buffer()");
    /* "- 2" to take care of EOB's */
    YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int)(new_size - 2);
  }

  (yy_n_chars) += number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

  (yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state(void)
{
  yy_state_type yy_current_state;
  char* yy_cp;

  yy_current_state = (yy_start);
  yy_current_state += YY_AT_BOL();

  for (yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp)
  {
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if (yy_accept[yy_current_state])
    {
      (yy_last_accepting_state) = yy_current_state;
      (yy_last_accepting_cpos) = yy_cp;
    }
    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
    {
      yy_current_state = (int)yy_def[yy_current_state];
      if (yy_current_state >= 981)
        yy_c = yy_meta[yy_c];
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
  }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *  next_state = yy_try_NUL_trans( current_state );
 */
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state)
{
  int yy_is_jam;
  char* yy_cp = (yy_c_buf_p);

  YY_CHAR yy_c = 1;
  if (yy_accept[yy_current_state])
  {
    (yy_last_accepting_state) = yy_current_state;
    (yy_last_accepting_cpos) = yy_cp;
  }
  while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
  {
    yy_current_state = (int)yy_def[yy_current_state];
    if (yy_current_state >= 981)
      yy_c = yy_meta[yy_c];
  }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
  yy_is_jam = (yy_current_state == 980);

  return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

static void yyunput(int c, char* yy_bp)
{
  char* yy_cp;

  yy_cp = (yy_c_buf_p);

  /* undo effects of setting up yytext */
  *yy_cp = (yy_hold_char);

  if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
  { /* need to shift things up to make room */
    /* +2 for EOB chars. */
    int number_to_move = (yy_n_chars) + 2;
    char* dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
    char* source = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

    while (source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      *--dest = *--source;

    yy_cp += (int)(dest - source);
    yy_bp += (int)(dest - source);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) =
      (int)YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

    if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
      YY_FATAL_ERROR("flex scanner push-back overflow");
  }

  *--yy_cp = (char)c;

  if (c == '\n')
  {
    --yylineno;
  }

  (yytext_ptr) = yy_bp;
  (yy_hold_char) = *yy_cp;
  (yy_c_buf_p) = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput(void)
#else
static int input(void)
#endif

{
  int c;

  *(yy_c_buf_p) = (yy_hold_char);

  if (*(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR)
  {
    /* yy_c_buf_p now points to the character we want to return.
     * If this occurs *before* the EOB characters, then it's a
     * valid NUL; if not, then we've hit the end of the buffer.
     */
    if ((yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
      /* This was really a NUL. */
      *(yy_c_buf_p) = '\0';

    else
    { /* need more input */
      int offset = (int)((yy_c_buf_p) - (yytext_ptr));
      ++(yy_c_buf_p);

      switch (yy_get_next_buffer())
      {
        case EOB_ACT_LAST_MATCH:
          /* This happens because yy_g_n_b()
           * sees that we've accumulated a
           * token and flags that we need to
           * try matching the token before
           * proceeding.  But for input(),
           * there's no matching to consider.
           * So convert the EOB_ACT_LAST_MATCH
           * to EOB_ACT_END_OF_FILE.
           */

          /* Reset buffer status. */
          yyrestart(yyin);

          /*FALLTHROUGH*/

        case EOB_ACT_END_OF_FILE:
        {
          if (yywrap())
            return 0;

          if (!(yy_did_buffer_switch_on_eof))
            YY_NEW_FILE;
#ifdef __cplusplus
          return yyinput();
#else
          return input();
#endif
        }

        case EOB_ACT_CONTINUE_SCAN:
          (yy_c_buf_p) = (yytext_ptr) + offset;
          break;
      }
    }
  }

  c = *(unsigned char*)(yy_c_buf_p); /* cast for 8-bit char's */
  *(yy_c_buf_p) = '\0';              /* preserve yytext */
  (yy_hold_char) = *++(yy_c_buf_p);

  YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
  if (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

    yylineno++;
  ;

  return c;
}
#endif /* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyrestart(FILE* input_file)
{

  if (!YY_CURRENT_BUFFER)
  {
    yyensure_buffer_stack();
    YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
  }

  yy_init_buffer(YY_CURRENT_BUFFER, input_file);
  yy_load_buffer_state();
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 *
 */
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)
{

  /* TODO. We should be able to replace this entire function body
   * with
   *    yypop_buffer_state();
   *    yypush_buffer_state(new_buffer);
   */
  yyensure_buffer_stack();
  if (YY_CURRENT_BUFFER == new_buffer)
    return;

  if (YY_CURRENT_BUFFER)
  {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p) = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  YY_CURRENT_BUFFER_LVALUE = new_buffer;
  yy_load_buffer_state();

  /* We don't actually know whether we did this switch during
   * EOF (yywrap()) processing, but the only time this flag
   * is looked at is after yywrap() is called, so it's safe
   * to go ahead and always set it.
   */
  (yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state(void)
{
  (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
  (yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
  yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
  (yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 *
 * @return the allocated buffer state.
 */
YY_BUFFER_STATE yy_create_buffer(FILE* file, int size)
{
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
  if (!b)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char*)yyalloc((yy_size_t)(b->yy_buf_size + 2));
  if (!b->yy_ch_buf)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_is_our_buffer = 1;

  yy_init_buffer(b, file);

  return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 *
 */
void yy_delete_buffer(YY_BUFFER_STATE b)
{

  if (!b)
    return;

  if (b == YY_CURRENT_BUFFER) /* Not sure if we should pop here. */
    YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE)0;

  if (b->yy_is_our_buffer)
    yyfree((void*)b->yy_ch_buf);

  yyfree((void*)b);
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
static void yy_init_buffer(YY_BUFFER_STATE b, FILE* file)

{
  int oerrno = errno;

  yy_flush_buffer(b);

  b->yy_input_file = file;
  b->yy_fill_buffer = 1;

  /* If b is the current buffer, then yy_init_buffer was _probably_
   * called from yyrestart() or through yy_get_next_buffer.
   * In that case, we don't want to reset the lineno or column.
   */
  if (b != YY_CURRENT_BUFFER)
  {
    b->yy_bs_lineno = 1;
    b->yy_bs_column = 0;
  }

  b->yy_is_interactive = file ? (isatty(fileno(file)) > 0) : 0;

  errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
void yy_flush_buffer(YY_BUFFER_STATE b)
{
  if (!b)
    return;

  b->yy_n_chars = 0;

  /* We always need two end-of-buffer characters.  The first causes
   * a transition to the end-of-buffer state.  The second causes
   * a jam in that state.
   */
  b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
  b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

  b->yy_buf_pos = &b->yy_ch_buf[0];

  b->yy_at_bol = 1;
  b->yy_buffer_status = YY_BUFFER_NEW;

  if (b == YY_CURRENT_BUFFER)
    yy_load_buffer_state();
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *
 */
void yypush_buffer_state(YY_BUFFER_STATE new_buffer)
{
  if (new_buffer == NULL)
    return;

  yyensure_buffer_stack();

  /* This block is copied from yy_switch_to_buffer. */
  if (YY_CURRENT_BUFFER)
  {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p) = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  /* Only push if top exists. Otherwise, replace top. */
  if (YY_CURRENT_BUFFER)
    (yy_buffer_stack_top)++;
  YY_CURRENT_BUFFER_LVALUE = new_buffer;

  /* copied from yy_switch_to_buffer. */
  yy_load_buffer_state();
  (yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *
 */
void yypop_buffer_state(void)
{
  if (!YY_CURRENT_BUFFER)
    return;

  yy_delete_buffer(YY_CURRENT_BUFFER);
  YY_CURRENT_BUFFER_LVALUE = NULL;
  if ((yy_buffer_stack_top) > 0)
    --(yy_buffer_stack_top);

  if (YY_CURRENT_BUFFER)
  {
    yy_load_buffer_state();
    (yy_did_buffer_switch_on_eof) = 1;
  }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack(void)
{
  yy_size_t num_to_alloc;

  if (!(yy_buffer_stack))
  {

    /* First allocation is just for 2 elements, since we don't know if this
     * scanner will even need a stack. We use 2 instead of 1 to avoid an
     * immediate realloc on the next call.
     */
    num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
    (yy_buffer_stack) =
      (struct yy_buffer_state**)yyalloc(num_to_alloc * sizeof(struct yy_buffer_state*));
    if (!(yy_buffer_stack))
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));

    (yy_buffer_stack_max) = num_to_alloc;
    (yy_buffer_stack_top) = 0;
    return;
  }

  if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1)
  {

    /* Increase the buffer to prepare for a possible push. */
    yy_size_t grow_size = 8 /* arbitrary grow size */;

    num_to_alloc = (yy_buffer_stack_max) + grow_size;
    (yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc(
      (yy_buffer_stack), num_to_alloc * sizeof(struct yy_buffer_state*));
    if (!(yy_buffer_stack))
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    /* zero only the new slots.*/
    memset(
      (yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
    (yy_buffer_stack_max) = num_to_alloc;
  }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer(char* base, yy_size_t size)
{
  YY_BUFFER_STATE b;

  if (size < 2 || base[size - 2] != YY_END_OF_BUFFER_CHAR ||
    base[size - 1] != YY_END_OF_BUFFER_CHAR)
    /* They forgot to leave room for the EOB's. */
    return NULL;

  b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
  if (!b)
    YY_FATAL_ERROR("out of dynamic memory in yy_scan_buffer()");

  b->yy_buf_size = (int)(size - 2); /* "- 2" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = NULL;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  yy_switch_to_buffer(b);

  return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 *
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string(const char* yystr)
{

  return yy_scan_bytes(yystr, (int)strlen(yystr));
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes(const char* yybytes, int _yybytes_len)
{
  YY_BUFFER_STATE b;
  char* buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = (yy_size_t)(_yybytes_len + 2);
  buf = (char*)yyalloc(n);
  if (!buf)
    YY_FATAL_ERROR("out of dynamic memory in yy_scan_bytes()");

  for (i = 0; i < _yybytes_len; ++i)
    buf[i] = yybytes[i];

  buf[_yybytes_len] = buf[_yybytes_len + 1] = YY_END_OF_BUFFER_CHAR;

  b = yy_scan_buffer(buf, n);
  if (!b)
    YY_FATAL_ERROR("bad buffer in yy_scan_bytes()");

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error(const char* msg)
{
  fprintf(stderr, "%s\n", msg);
  exit(YY_EXIT_FAILURE);
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                                                                                  \
  do                                                                                               \
  {                                                                                                \
    /* Undo effects of setting up yytext. */                                                       \
    int yyless_macro_arg = (n);                                                                    \
    YY_LESS_LINENO(yyless_macro_arg);                                                              \
    yytext[yyleng] = (yy_hold_char);                                                               \
    (yy_c_buf_p) = yytext + yyless_macro_arg;                                                      \
    (yy_hold_char) = *(yy_c_buf_p);                                                                \
    *(yy_c_buf_p) = '\0';                                                                          \
    yyleng = yyless_macro_arg;                                                                     \
  } while (0)

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 *
 */
int yyget_lineno(void)
{

  return yylineno;
}

/** Get the input stream.
 *
 */
FILE* yyget_in(void)
{
  return yyin;
}

/** Get the output stream.
 *
 */
FILE* yyget_out(void)
{
  return yyout;
}

/** Get the length of the current token.
 *
 */
int yyget_leng(void)
{
  return yyleng;
}

/** Get the current token.
 *
 */

char* yyget_text(void)
{
  return yytext;
}

/** Set the current line number.
 * @param _line_number line number
 *
 */
void yyset_lineno(int _line_number)
{

  yylineno = _line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 *
 * @see yy_switch_to_buffer
 */
void yyset_in(FILE* _in_str)
{
  yyin = _in_str;
}

void yyset_out(FILE* _out_str)
{
  yyout = _out_str;
}

int yyget_debug(void)
{
  return yy_flex_debug;
}

void yyset_debug(int _bdebug)
{
  yy_flex_debug = _bdebug;
}

static int yy_init_globals(void)
{
  /* Initialization is the same as for the non-reentrant scanner.
   * This function is called from yylex_destroy(), so don't allocate here.
   */

  /* We do not touch yylineno unless the option is enabled. */
  yylineno = 1;

  (yy_buffer_stack) = NULL;
  (yy_buffer_stack_top) = 0;
  (yy_buffer_stack_max) = 0;
  (yy_c_buf_p) = NULL;
  (yy_init) = 0;
  (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
  yyin = stdin;
  yyout = stdout;
#else
  yyin = NULL;
  yyout = NULL;
#endif

  /* For future reference: Set errno on error, since we are called by
   * yylex_init()
   */
  return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy(void)
{

  /* Pop the buffer stack, destroying each element. */
  while (YY_CURRENT_BUFFER)
  {
    yy_delete_buffer(YY_CURRENT_BUFFER);
    YY_CURRENT_BUFFER_LVALUE = NULL;
    yypop_buffer_state();
  }

  /* Destroy the stack itself. */
  yyfree((yy_buffer_stack));
  (yy_buffer_stack) = NULL;

  /* Reset the globals. This is important in a non-reentrant scanner so the next time
   * yylex() is called, initialization will occur. */
  yy_init_globals();

  return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy(char* s1, const char* s2, int n)
{

  int i;
  for (i = 0; i < n; ++i)
    s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char* s)
{
  int n;
  for (n = 0; s[n]; ++n)
    ;

  return n;
}
#endif

void* yyalloc(yy_size_t size)
{
  return malloc(size);
}

void* yyrealloc(void* ptr, yy_size_t size)
{

  /* The cast to (char *) in the following accommodates both
   * implementations that use char* generic pointers, and those
   * that use void* generic pointers.  It works with the latter
   * because both ANSI C and C++ allow castless assignment from
   * any pointer type to void*, and deal with argument conversions
   * as though doing an assignment.
   */
  return realloc(ptr, size);
}

void yyfree(void* ptr)
{
  free((char*)ptr); /* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

/*
 * Return a parenthetical macro arg list as a new string.
 */
char* get_macro_arguments()
{
  char* cp = NULL;
  size_t i = 0;
  int depth;
  int ws = 0;
  int sl = 0;
  int c1 = input();

  if (c1 == '\0')
  {
    if (pop_buffer() == 0)
    {
      return NULL;
    }
  }

  while (c1 == ' ' || c1 == '\t' || c1 == '\r' || c1 == '\n')
  {
    c1 = input();
  }

  cp = (char*)malloc(4);

  if (c1 != '(')
  {
    unput(c1);
    free(cp);
    return NULL;
  }

  cp[i++] = '(';
  depth = 1;
  c1 = input();

  for (;;)
  {
    ws = 0;
    sl = 0;
    /* skip all whitespace */
    while (c1 == ' ' || c1 == '\t' || c1 == '\r' || c1 == '\n')
    {
      ws = 1;
      c1 = input();
    }
    if (c1 == '/')
    {
      c1 = input();
      if (c1 == '*')
      {
        /* skip a C style comment */
        ws = 1;
        if (skip_comment() == 0)
        {
          return NULL;
        }
        c1 = input();
      }
      else if (c1 == '/')
      {
        /* skip a C++ style comment */
        ws = 1;
        do
        {
          c1 = input();
        } while (c1 != '\n' && c1 != '\0');
        if (c1 == '\0')
        {
          return NULL;
        }
        c1 = input();
      }
      else
      {
        sl = 1;
      }
    }
    if (ws)
    {
      /* add a single space to replace any whitespace */
      cp[i++] = ' ';
      if (i >= 4 && (i & (i - 1)) == 0)
      {
        char* oldcp = cp;
        cp = (char*)realloc(cp, 2 * i);
        if (!cp)
        {
          free(oldcp);
          return NULL;
        }
      }
    }
    if (sl)
    {
      /* add a single space to replace any whitespace */
      cp[i++] = '/';
      if (i >= 4 && (i & (i - 1)) == 0)
      {
        char* oldcp = cp;
        cp = (char*)realloc(cp, 2 * i);
        if (!cp)
        {
          free(oldcp);
          return NULL;
        }
      }
    }
    if (c1 == '\"' || c1 == '\'')
    {
      int c2 = c1;
      int escaped = 2;
      int firstloop = 1;
      do
      {
        if (escaped)
        {
          --escaped;
        }
        if (!firstloop)
        {
          c1 = input();
        }
        firstloop = 0;
        if (c1 == '\0')
        {
          break;
        }
        if (escaped == 0 && c1 == '\\')
        {
          escaped = 2;
        }
        cp[i++] = (char)c1;
        if (i >= 4 && (i & (i - 1)) == 0)
        {
          char* oldcp = cp;
          cp = (char*)realloc(cp, 2 * i);
          if (!cp)
          {
            free(oldcp);
            return NULL;
          }
        }
      } while (c1 != c2 || escaped);
    }
    else if (c1 != '\0')
    {
      cp[i++] = (char)c1;
      if (i >= 4 && (i & (i - 1)) == 0)
      {
        char* oldcp = cp;
        cp = (char*)realloc(cp, 2 * i);
        if (!cp)
        {
          free(oldcp);
          return NULL;
        }
      }
      cp[i] = '\0';
      if (c1 == '(')
      {
        depth++;
      }
      if (c1 == ')')
      {
        if (--depth == 0)
        {
          break;
        }
      }
    }
    else
    {
      return NULL;
    }
    c1 = input();
  }

  return cp;
}

/*
 * Skip a C-style comment, return 0 if unterminated.
 */
int skip_comment()
{
  int savelineno = yylineno;
  int c1 = 0, c2 = input();
  for (;;)
  {
    if (c2 == 0 || c2 == EOF)
    {
      yylineno = savelineno;
      print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, "Cannot find end of comment.", 27);
      exit(1);
    }
    if (c1 == '*' && c2 == '/')
      break;
    c1 = c2;
    c2 = input();
  }
  return 1;
}

/*
 * If token contains a comment, make sure whole comment is skipped.
 */
int skip_trailing_comment(const char* text, size_t l)
{
  const char* cp = text;
  const char* ep = text + l;
  int incomment = 0;

  while (cp < ep)
  {
    while (cp < ep && *cp != '/' && *cp != '\"')
    {
      cp++;
    }
    if (cp >= ep)
    {
      break;
    }
    else if (cp[0] == '/' && cp[1] == '*')
    {
      incomment = 1;
      cp += 2;
      while (cp < ep && *cp != '*')
      {
        cp++;
      }
      if (cp[0] == '*' && cp[1] == '/')
      {
        incomment = 0;
        cp += 2;
      }
      else
      {
        cp++;
      }
    }
    else if (cp[0] == '\"')
    {
      cp++;
      while (cp < ep)
      {
        while (cp < ep && *cp != '\\' && *cp != '\"')
        {
          cp++;
        }
        if (cp >= ep)
        {
          break;
        }
        else if (*cp == '\"')
        {
          cp++;
          break;
        }
        else /* if (*cp == '\\') */
        {
          cp += 2;
        }
      }
    }
    else
    {
      cp++;
    }
  }

  if (incomment)
  {
    return skip_comment();
  }

  return 1;
}

/*
 * Skip ahead until the next preprocessor directive.
 * This will eat the '#' that starts the directive.
 * Return 0 if none found.
 */
int skip_to_next_directive()
{
  /* state == 0 at the start of a line */
  int state = 0;
  int c;

  c = input();

  while (c != 0 && c != EOF)
  {
    /* whitespace */
    if (c == ' ' || c == '\t')
    {
      c = input();
    }
    /* newline renews the start-of-line state */
    else if (c == '\n')
    {
      state = 0;
      c = input();
    }
    /* skip comments */
    else if (c == '/')
    {
      state = 1;
      if ((c = input()) == '*')
      {
        if (skip_comment() == 0)
        {
          return 0;
        }
        c = input();
      }
    }
    /* skip escaped characters */
    else if (c == '\\')
    {
      state = 1;
      if ((c = input()) == '\r')
      {
        if ((c = input()) == '\n')
        {
          c = input();
        }
      }
      else if (c != 0 && c != EOF)
      {
        c = input();
      }
    }
    /* any other chars except '#' at start of line */
    else if (c != '#' || state != 0)
    {
      state = 1;
      c = input();
    }
    else
    {
      break;
    }
  }

  return c;
}

/*
 * Skip to the next #else or #elif or #endif
 */
int skip_conditional_block()
{
  static char* linebuf = NULL;
  static size_t linemaxlen = 80;
  size_t i;
  int c;
  int result;

  if (linebuf == 0)
  {
    linebuf = (char*)malloc(linemaxlen);
  }

  for (;;)
  {
    if (skip_to_next_directive() == 0)
    {
      return 0;
    }
    c = input();
    while (c == ' ' || c == '\t')
    {
      c = input();
    }
    if (c == 0 || c == EOF)
    {
      return 0;
    }

    /* eat the whole line */
    i = 0;
    linebuf[i++] = '#';
    while (c != 0 && c != EOF && c != '\n')
    {
      if (i >= linemaxlen - 5)
      {
        char* oldlinebuf = linebuf;
        linemaxlen += i + 5;
        linebuf = (char*)realloc(linebuf, linemaxlen);
        if (!linebuf)
        {
          free(oldlinebuf);
          return 0;
        }
      }
      linebuf[i++] = c;
      /* be sure to skip escaped newlines */
      if (c == '\\')
      {
        c = input();
        linebuf[i++] = c;
        if (c == '\r')
        {
          c = input();
          linebuf[i++] = c;
        }
      }
      c = input();
    }
    linebuf[i++] = c;

    result = vtkParsePreprocess_HandleDirective(preprocessor, linebuf);
    if (result != VTK_PARSE_SKIP && result != VTK_PARSE_OK)
    {
      print_preprocessor_error(result, linebuf, i);
    }
    else if (result != VTK_PARSE_SKIP)
    {
      break;
    }
  }

  return 1;
}

/*
 * Skip ahead until one of the strings is found,
 * then skip to the end of the line.
 */
int skip_ahead_multi(const char* strings[])
{
  char textbuf[SKIP_MATCH_MAXLEN + 1];
  int c = 0;
  size_t i;

  for (i = 0; i < (SKIP_MATCH_MAXLEN + 1); i++)
  {
    textbuf[i] = '\0';
  }

  for (;;)
  {
    for (i = 0; i < SKIP_MATCH_MAXLEN; i++)
    {
      textbuf[i] = textbuf[i + 1];
    }

    c = input();
    if (c == 0 || c == EOF)
    {
      print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, NULL, 0);
      return 0;
    }

    textbuf[SKIP_MATCH_MAXLEN - 1] = c;

    for (i = 0; strings[i]; i++)
    {
      if (strcmp(&textbuf[SKIP_MATCH_MAXLEN - strlen(strings[i])], strings[i]) == 0)
      {
        break;
      }
    }
    if (strings[i])
    {
      break;
    }
  }

  while (c != 0 && c != EOF && c != '\n')
  {
    c = input();
  }

  return 1;
}

/*
 * Skip ahead until the string is found.
 */
int skip_ahead_until(const char* text)
{
  const char* strings[2];
  strings[0] = text;
  strings[1] = NULL;

  return skip_ahead_multi(strings);
}

/*
 * Called for doxygen C-style comments
 */
void doxygen_comment()
{
  char linetext[256];
  int savelineno = yylineno;
  int asterisk, isfirstline = 1;
  int type = DoxygenComment;
  int l = 0, i = 0, base = yyleng;
  int c1 = 0, c2 = input();
  for (l = 0; l < yyleng; l++)
  {
    linetext[l] = yytext[l];
  }
  if (l > 0 && yytext[l - 1] == '<')
  {
    type = TrailingComment;
  }
  for (;;)
  {
    if (c2 == 0 || c2 == EOF)
    {
      yylineno = savelineno;
      print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, "Cannot find end of comment.", 27);
      exit(1);
    }
    if (l < 256)
    {
      linetext[l++] = (char)c2;
    }
    if (c2 == '\n' || (c1 == '*' && c2 == '/'))
    {
      if (l >= 2 && linetext[l - 2] == '*' && linetext[l - 1] == '/')
      {
        l -= 2;
      }
      while (l > 0 &&
        (linetext[l - 1] == '\n' || linetext[l - 1] == '\r' || linetext[l - 1] == '\t' ||
          linetext[l - 1] == ' '))
      {
        l--;
      }
      if (!isfirstline)
      {
        /* reduce the base indentation if chars occur before base */
        asterisk = 0;
        for (i = yyleng - 3; i < base && i < l; i++)
        {
          if (linetext[i] == '*' && asterisk == 0)
          {
            asterisk = 1;
          }
          else if (linetext[i] != ' ')
          {
            break;
          }
        }
        if (i > yyleng - 3 && i < l && linetext[i] != ' ' && linetext[i - 1] == ' ')
        {
          i--;
        }
        base = i;
      }
      if (l > base)
      {
        i = base;
        l -= base;
        addCommentLine(&linetext[i], l, type);
      }
      else if (c1 != '*' || c2 != '/')
      {
        addCommentLine("", 0, type);
      }
      if (isfirstline)
      {
        isfirstline = 0;
        base = 256;
      }
      l = 0;
      if (c1 == '*' && c2 == '/')
      {
        break;
      }
    }
    c1 = c2;
    c2 = input();
  }
}

/*
 * Called for //! and /// doxygen comments (handles just one line)
 */
void doxygen_cpp_comment()
{
  int type = DoxygenComment;
  int pos = 2;
  while (yytext[pos - 2] != '/' || yytext[pos - 1] != '/')
    pos++;
  while (pos < yyleng && yytext[pos - 1] == '/' && yytext[pos] == '/')
    pos++;
  if (pos < yyleng && yytext[pos] == '!')
    pos++;
  if (pos < yyleng && yytext[pos] == '<')
  {
    pos++;
    type = TrailingComment;
  }
  addCommentLine(&yytext[pos], yyleng - pos, type);
}

/*
 * Called for //@{
 */
void doxygen_group_start()
{
  /* Set the "ingroup" marker */
  setCommentMemberGroup(1);
}

/*
 * Called for //@}
 */
void doxygen_group_end()
{
  /* Clear the "ingroup" marker */
  setCommentMemberGroup(0);
}

/*
 * Called for // Description:
 */
void vtk_comment()
{
  setCommentState(NormalComment);
}

/*
 * Called for // .NAME
 */
void vtk_name_comment()
{
  int pos = 1;
  while (yytext[pos - 1] != 'M' || yytext[pos] != 'E')
  {
    pos++;
  }
  pos++;
  setCommentState(NameComment);
  addCommentLine(&yytext[pos], yyleng - pos, NormalComment);
}

/*
 * Called for // .SECTION
 */
void vtk_section_comment()
{
  int pos = 1;
  while (yytext[pos - 1] != 'O' || yytext[pos] != 'N')
  {
    pos++;
  }
  pos++;
  if (pos < yyleng && yytext[pos] == ' ')
  {
    pos++;
  }

  if (yyleng - pos >= 11 && strncmp(&yytext[pos], "Description", 11) == 0)
  {
    setCommentState(DescriptionComment);
  }
  else if (yyleng - pos >= 8 &&
    (strncmp(&yytext[pos], "See Also", 8) == 0 || strncmp(&yytext[pos], "see also", 8) == 0))
  {
    setCommentState(SeeAlsoComment);
  }
  else if (yyleng - pos >= 7 && strncmp(&yytext[pos], "Caveats", 7) == 0)
  {
    setCommentState(CaveatsComment);
  }
  else
  {
    cpp_comment_line();
  }
}

/*
 * Called for each line that has a C++ comment but no code, unless the
 * comment is recognized as beginning a VTK or doxygen comment.
 */
void cpp_comment_line()
{
  int pos = 2;
  while (yytext[pos - 2] != '/' || yytext[pos - 1] != '/')
    pos++;
  addCommentLine(&yytext[pos], yyleng - pos, NormalComment);
}

/*
 * Called whenever a blank line is encountered.
 */
void blank_line()
{
  commentBreak();
}

/*
 * Convert a raw string into a non-raw string.
 */
const char* raw_string(const char* begin)
{
  int savelineno = yylineno;
  char* textbuf;
  int c = 0;
  const char* delim;
  const char* cp = begin;
  char* dp;
  char* result;
  size_t i, j, n;
  size_t m = 1024;

  result = (char*)malloc(m);
  dp = result;

  while (*cp != '\"')
  {
    *dp++ = *cp++;
  }
  --dp;
  *dp++ = *cp++;

  delim = cp;

  for (n = 0;; n++)
  {
    if (delim[n] == '(')
    {
      break;
    }
  }

  textbuf = (char*)malloc(n + 1);

  for (i = 0; i < n + 1; i++)
  {
    c = input();
    textbuf[i] = c;
  }

  while (c != EOF)
  {
    if (textbuf[0] == ')' && (n == 0 || strncmp(&textbuf[1], delim, n) == 0))
    {
      break;
    }

    j = dp - result;
    if (j > m - 8)
    {
      m += 1024;
      result = (char*)realloc(result, m);
      if (!result)
      {
        print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
        exit(1);
      }
      dp = result + j;
    }

    if ((*textbuf >= ' ' && *textbuf <= '~') || (*textbuf & 0x80) != 0)
    {
      *dp++ = *textbuf;
    }
    else
      switch (*textbuf)
      {
        case '\a':
          *dp++ = '\\';
          *dp++ = 'a';
          break;
        case '\b':
          *dp++ = '\\';
          *dp++ = 'b';
          break;
        case '\f':
          *dp++ = '\\';
          *dp++ = 'f';
          break;
        case '\n':
          *dp++ = '\\';
          *dp++ = 'n';
          break;
        case '\r':
          *dp++ = '\\';
          *dp++ = 'r';
          break;
        case '\t':
          *dp++ = '\\';
          *dp++ = 't';
          break;
        case '\v':
          *dp++ = '\\';
          *dp++ = 'v';
          break;
        case '\\':
          *dp++ = '\\';
          *dp++ = '\\';
          break;
        case '\'':
          *dp++ = '\\';
          *dp++ = '\'';
          break;
        case '\"':
          *dp++ = '\\';
          *dp++ = '\"';
          break;
        default:
          sprintf(dp, "\\%3.3o", *textbuf);
          dp += 4;
          break;
      }

    for (i = 0; i < n; i++)
    {
      textbuf[i] = textbuf[i + 1];
    }

    c = input();
    textbuf[n] = c;
  }

  if (c == EOF || '\"' != input())
  {
    yylineno = savelineno;
    print_preprocessor_error(VTK_PARSE_SYNTAX_ERROR, "Unterminated raw string.", 24);
    exit(1);
  }

  *dp++ = '\"';

  c = input();
  if (c == '_')
  {
    do
    {
      *dp++ = c;
      c = input();
    } while (vtkParse_CharType(c, CPRE_XID));
  }
  unput(c);

  *dp = '\0';
  cp = vtkstrdup(result);
  free(result);
  free(textbuf);

  return cp;
}

/*
 * buffer stack, used for macro expansion and include files
 */
static size_t buffer_stack_size = 0;
static YY_BUFFER_STATE* buffer_stack = NULL;

/*
 * push the current buffer onto the buffer stack.
 */
void push_buffer()
{
  size_t n = buffer_stack_size;
  if (buffer_stack == NULL)
  {
    buffer_stack = (YY_BUFFER_STATE*)malloc(4 * sizeof(YY_BUFFER_STATE));
  }
  /* grow the stack whenever size reaches a power of two */
  else if (n >= 4 && (n & (n - 1)) == 0)
  {
    buffer_stack = (YY_BUFFER_STATE*)realloc(buffer_stack, 2 * n * sizeof(YY_BUFFER_STATE));
    if (!buffer_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
  }
  buffer_stack[buffer_stack_size++] = YY_CURRENT_BUFFER;
}

/*
 * pop the buffer stack and restore the previous buffer
 */
int pop_buffer()
{
  if (in_macro())
  {
    pop_macro();
  }
  else
  {
    pop_include();
  }
  if (buffer_stack_size == 0)
  {
    return 0;
  }
  yy_delete_buffer(YY_CURRENT_BUFFER);
  yy_switch_to_buffer(buffer_stack[--buffer_stack_size]);
  return 1;
}

/*
 * include stack, to tell what include is being evaluated
 */
static size_t include_stack_size = 0;
static FileInfo** include_stack = NULL;
static int* lineno_stack = NULL;

/*
 * push the current include onto the include stack.
 */
void push_include(const char* filename)
{
  FileInfo* file_info = NULL;
  int same_file = 0;
  size_t n = include_stack_size;

  if (include_stack == NULL)
  {
    include_stack = (FileInfo**)malloc(4 * sizeof(FileInfo*));
    lineno_stack = (int*)malloc(4 * sizeof(int));
  }

  /* grow the stack whenever size reaches a power of two */
  else if (n >= 4 && (n & (n - 1)) == 0)
  {
    include_stack = (FileInfo**)realloc(include_stack, 2 * n * sizeof(FileInfo*));
    if (!include_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
    lineno_stack = (int*)realloc(lineno_stack, 2 * n * sizeof(int));
    if (!lineno_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
  }

  lineno_stack[include_stack_size] = yyget_lineno();
  yyset_lineno(0);
  include_stack[include_stack_size++] = data;

  /* if the file is including itself */
  if (filename == data->FileName ||
    (filename != 0 && data->FileName != 0 && strcmp(filename, data->FileName) == 0))
  {
    same_file = 1;
  }

  /* make a new fileinfo, but only if we are in the base namespace
   * and only if the only items added so far are constants */
  if (!same_file && currentNamespace == data->Contents &&
    data->Contents->NumberOfItems == data->Contents->NumberOfConstants)
  {
    file_info = (FileInfo*)malloc(sizeof(FileInfo));
    vtkParse_InitFile(file_info);
    file_info->FileName = vtkstrdup(filename);
    file_info->Contents = (NamespaceInfo*)malloc(sizeof(NamespaceInfo));
    vtkParse_InitNamespace(file_info->Contents);
    vtkParse_AddIncludeToFile(data, file_info);
    file_info->Strings = data->Strings;
    data = file_info;
    currentNamespace = file_info->Contents;
  }
}

/*
 * pop the include stack
 */
void pop_include()
{
  if (include_stack_size > 0)
  {
    --include_stack_size;
    fclose(yyin);
    yyset_lineno(lineno_stack[include_stack_size]);
    if (data != include_stack[include_stack_size])
    {
      data = include_stack[include_stack_size];
      currentNamespace = data->Contents;
    }
  }
}

/*
 * macro stack, to tell what macro is being evaluated
 */
static size_t macro_stack_size = 0;
static MacroInfo** macro_stack = NULL;

/*
 * push the current macro onto the macro stack.
 */
void push_macro(MacroInfo* macro)
{
  size_t n = macro_stack_size;
  if (macro_stack == NULL)
  {
    macro_stack = (MacroInfo**)malloc(4 * sizeof(MacroInfo*));
  }
  /* grow the stack whenever size reaches a power of two */
  else if (n >= 4 && (n & (n - 1)) == 0)
  {
    macro_stack = (MacroInfo**)realloc(macro_stack, 2 * n * sizeof(MacroInfo*));
    if (!macro_stack)
    {
      print_preprocessor_error(VTK_PARSE_OUT_OF_MEMORY, NULL, 0);
      exit(1);
    }
  }
  macro_stack[macro_stack_size++] = macro;
  if (macro)
  {
    macro->IsExcluded = 1;
    if (macro_stack_size == 1)
    {
      macroName = macro->Name;
      macroUsed = 0;
      macroEnded = 0;
    }
  }
}

/*
 * pop the macro stack
 */
void pop_macro()
{
  MacroInfo* macro;

  if (macro_stack_size > 0)
  {
    macro = macro_stack[--macro_stack_size];
    if (macro)
    {
      macro->IsExcluded = 0;
    }
  }
  macroEnded = 1;
}

/*
 * are we currently processing a macro?
 */
int in_macro()
{
  return (macro_stack_size > 0);
}

/*
 * print a preprocessor error code with filename and line number.
 */
void print_preprocessor_error(int result, const char* cp, size_t n)
{
  const char* text = "";

  switch (result)
  {
    case VTK_PARSE_OK:
    case VTK_PARSE_SKIP:
      return;
    case VTK_PARSE_PREPROC_DOUBLE:
      text = "double in preprocessor conditional";
      break;
    case VTK_PARSE_PREPROC_FLOAT:
      text = "float in preprocessor conditional";
      break;
    case VTK_PARSE_PREPROC_STRING:
      text = "string in preprocessor conditional";
      break;
    case VTK_PARSE_MACRO_UNDEFINED:
      text = "undefined macro";
      break;
    case VTK_PARSE_MACRO_REDEFINED:
      text = "redefined macro";
      break;
    case VTK_PARSE_FILE_NOT_FOUND:
      text = "file not found";
      break;
    case VTK_PARSE_FILE_OPEN_ERROR:
      text = "can\'t open file";
      break;
    case VTK_PARSE_FILE_READ_ERROR:
      text = "input/output error";
      break;
    case VTK_PARSE_MACRO_NUMARGS:
      text = "wrong number of macro args";
      break;
    case VTK_PARSE_SYNTAX_ERROR:
      text = "syntax error";
      break;
    case VTK_PARSE_OUT_OF_MEMORY:
      text = "out of memory";
      break;
  }

  /* be silent about missing include files */
  if (result == VTK_PARSE_FILE_NOT_FOUND)
  {
    return;
  }

  print_parser_error(text, cp, n);
}

/*
 * print an error with filename and line number.
 */
void print_parser_error(const char* text, const char* cp, size_t n)
{
  size_t j = 0;
  const char* fn = "(none)";

  if (CommandName)
  {
    fprintf(yyout, "%s: ", CommandName);
  }

  if (data->FileName)
  {
    fn = data->FileName;
  }
  fprintf(yyout, "In %s:", fn);
  for (j = 0; j < include_stack_size; j++)
  {
    fprintf(yyout, "%i:\nIn %s:", lineno_stack[j], include_stack[j]->FileName);
  }
  fprintf(yyout, "%i:", yylineno);

  if (cp)
  {
    fprintf(yyout, " %s: %*.*s\n", text, (int)n, (int)n, cp);
  }
  else if (text)
  {
    fprintf(yyout, " %s.\n", text);
  }
  else
  {
    fprintf(yyout, "\n");
  }
}

/*
 * Execute a preprocessor directive.
 */
void preprocessor_directive(const char* text, size_t l)
{
  int result = 0;
  size_t n = 0;
  const char* cp = text;
  const char* ep = text + l;
  const char* directive = NULL;

  /* find the directive, store its length in "n" */
  while (*cp == ' ' || *cp == '\t')
  {
    cp++;
  }
  if (*cp == '#')
  {
    cp++;
  }
  while ((*cp == ' ' || *cp == '\t') && cp < ep)
  {
    cp++;
  }
  directive = cp;
  while (*cp >= 'a' && *cp <= 'z' && cp < ep)
  {
    cp++;
  }
  n = cp - directive;
  while ((*cp == ' ' || *cp == '\t') && cp < ep)
  {
    cp++;
  }

  if (n == 7 && strncmp(directive, "include", n) == 0)
  {
    /* include files */
    int already_loaded = 0;
    if (*cp == '<' || *cp == '\"')
    {
      /* if asked to recurse into header files */
      if (Recursive && ep - cp > 3)
      {
        const char* dp;
        dp = vtkParsePreprocess_FindIncludeFile(preprocessor, &cp[1],
          (*cp != '\"' ? VTK_PARSE_SYSTEM_INCLUDE : VTK_PARSE_SOURCE_INCLUDE), &already_loaded);
        if (dp)
        {
          yyin = fopen(dp, "r");
          if (yyin)
          {
            push_include(dp);
            push_buffer();
            yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));
            return;
          }
        }
      }
    }
  }

  /* let the preprocessor handle the directive */
  result = vtkParsePreprocess_HandleDirective(preprocessor, text);

  if (result == VTK_PARSE_SKIP)
  {
    skip_conditional_block();
  }
  else if (result != VTK_PARSE_OK)
  {
    print_preprocessor_error(result, text, l);
    if ((result & VTK_PARSE_FATAL_ERROR) != 0)
    {
      exit(1);
    }
  }
  else if (n == 6 && strncmp(directive, "define", n) == 0)
  {
    closeComment();
    if (ep - cp > 4 && strncmp(cp, "VTK", 3) == 0)
    {
      /* macros that start with "VTK" */
      MacroInfo* macro;

      macro = vtkParsePreprocess_GetMacro(preprocessor, cp);
      if (macro && macro->Definition && !macro->IsFunction)
      {
        /* if macro evaluates to a constant, add it as a constant */
        macro->IsExcluded = 1;
        if (guess_constant_type(macro->Definition) == 0)
        {
          result = VTK_PARSE_MACRO_UNDEFINED;
        }
        macro->IsExcluded = 0;
        if (result < VTK_PARSE_MACRO_UNDEFINED)
        {
          add_constant(vtkstrdup(macro->Name), vtkstrdup(macro->Definition), 0, 0, NULL, 1);
        }
      }
    }
  }
}
