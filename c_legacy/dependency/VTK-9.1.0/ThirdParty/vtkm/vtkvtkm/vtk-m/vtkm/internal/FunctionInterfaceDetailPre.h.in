//============================================================================
//  Copyright (c) Kitware, Inc.
//  All rights reserved.
//  See LICENSE.txt for details.
//
//  This software is distributed WITHOUT ANY WARRANTY; without even
//  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
//  PURPOSE.  See the above copyright notice for more information.
//============================================================================
$# This file uses the pyexpander macro processing utility to build the
$# FunctionInterface facilities that use a variable number of arguments.
$# Information, documentation, and downloads for pyexpander can be found at:
$#
$#     http://pyexpander.sourceforge.net/
$#
$# To build the source code, execute the following (after installing
$# pyexpander, of course):
$#
$#     expander.py FunctionInterfaceDetailPre.h.in > FunctionInterfaceDetailPre.h
$#
$# Ignore the following comment. It is meant for the generated file.
// **** DO NOT EDIT THIS FILE!!! ****
// This file is automatically generated by FunctionInterfaceDetailPre.h.in

#ifndef vtk_m_internal_FunctionInterfaceDetailPre_h
#define vtk_m_internal_FunctionInterfaceDetailPre_h

#if !defined(vtk_m_internal_FunctionInterface_h) && !defined(VTKM_TEST_HEADER_BUILD)
#error FunctionInterfaceDetailPre.h must be included from FunctionInterface.h
#endif

#include <vtkm/Types.h>
#include <vtkm/internal/IndexTag.h>

#include <type_traits>

#include <vtkm/internal/brigand.hpp>

$py(max_parameters=20)\
#define VTKM_MAX_FUNCTION_PARAMETERS $(max_parameters)

$# Python commands used in template expansion.
$py(
def comma_if(flag):
  if flag:
    return ','
  else:
    return '';

def ptype(num, name=""):
  if num == 0:
    return '%sR' % name
  else:
    return '%sP%d' % (name, num)

def template_params(num_params, start=0, name=''):
  if num_params < start:
    return ''
  result = 'typename %s' % ptype(start, name)
  for param in range(start+1, num_params+1):
    result += ',\n          typename %s' % ptype(param, name)
  return result

def signature(num_params, return_type=ptype(0), name=''):
  result = '%s(' % return_type
  if num_params > 0:
    result += ptype(1, name)
  for param in range(2, num_params+1):
    result += ', %s' % ptype(param, name)
  result += ')'
  return result
)\
$#
$extend(comma_if, ptype, template_params, signature)\

namespace vtkm
{
namespace internal
{

/// This struct is used internally by FunctionInterface to store the return
/// value of a function. There is a special implementation for a return type of
/// void, which stores nothing.
///
template <typename T>
struct FunctionInterfaceReturnContainer
{
  T Value;
  static constexpr bool VALID = true;
};

template <>
struct FunctionInterfaceReturnContainer<void>
{
  // Nothing to store for void return.
  static constexpr bool VALID = false;
};

namespace detail
{

//============================================================================

// This templated class contains the state of parameters. If you get a compiler
// error stating that this class is not specialized, that probably means that
// you are using FunctionInterface with an unsupported number of arguments.
template <typename FunctionSignature>
struct ParameterContainer;

// clang-format off

$for(num_params in range(0, max_parameters+1))\
template <$template_params(num_params)>
struct ParameterContainer<$signature(num_params)>
{
$for(param_index in range(1, num_params+1))\
  $ptype(param_index) Parameter$(param_index);
$endfor\
};

$endfor\
// clang-format on

//============================================================================
template <typename>
struct FunctionSigInfo;
template <typename R, typename... ArgTypes>
struct FunctionSigInfo<R(ArgTypes...)>
{
  static constexpr std::size_t Arity = sizeof...(ArgTypes);
  using ArityType = std::integral_constant<int, static_cast<int>(Arity)>;

  using ResultType = R;
  using Components = brigand::list<R, ArgTypes...>;
  using Parameters = brigand::list<ArgTypes...>;
};

template <int, typename>
struct AtType;
template <int Index, typename R, typename... ArgTypes>
struct AtType<Index, R(ArgTypes...)>
{
  using type = brigand::at_c<brigand::list<R, ArgTypes...>, Index>;
};

//============================================================================

// clang-format off

$for(param_index in range(1, max_parameters+1))\
VTKM_SUPPRESS_EXEC_WARNINGS
template <typename FunctionSignature>
VTKM_EXEC_CONT auto ParameterGet(const ParameterContainer<FunctionSignature>& parameters,
                                 vtkm::internal::IndexTag<$(param_index)>)
  -> decltype(parameters.Parameter$(param_index)) const&
{
  return parameters.Parameter$(param_index);
}
$endfor\

// clang-format on

//============================================================================

template <typename OriginalSignature, typename Transform>
struct FunctionInterfaceStaticTransformType;

// clang-format off

$for(num_params in range(0, max_parameters))\
$for(environment in ['Cont'])\
VTKM_SUPPRESS_EXEC_WARNINGS
template <typename Result,
          typename Transform,
          $template_params(num_params,0,'Original')>
VTKM_$(environment.upper()) Result DoStaticTransform$(environment)(
  const Transform& transform,
  ParameterContainer<$signature(num_params,ptype(0,'Original'),'Original')>& originalParameters)
{
$if(num_params < 1)\
  (void)transform;
  (void)originalParameters;
$else\
  return Result{
$for(param_index in range(1, num_params+1))\
    transform(originalParameters.Parameter$(param_index), vtkm::internal::IndexTag<$(param_index)>())$comma_if(param_index<num_params)
$endfor\
  };
$endif\
}

$endfor\
$endfor\
// clang-format on

} // namespace detail
}
} // namespace vtkm::internal

#endif //vtk_m_internal_FunctionInterfaceDetailPre_h
