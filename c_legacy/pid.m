%PID controller for a quad-propeller ASV 
% Useful references: 
% http://www.benripley.com/development/quadcopter-source-code-from-scratch/
% https://github.com/benripley/Arduino-Quadcopter
% https://en.wikipedia.org/wiki/PID_controller

% Trusters configuration of the ASV with motors labelled m1 to m4:

% m1             m2 (Force in ↓ direction along propeller shaft is +ve for m1 and m2)
% ---           ---
%  |             |
%  |             |
%  |             |
% -----------------
% |      ^        |
% |      |        |
% |      |        |
% -----------------
%  |             |
%  |             |
%  |             |
% ---           ---
% m3             m4  (Force in ↑ direction along propeller shaft is +ve for m3 and m4)



%INPUTS:
%current roll angle of ASV in body fixed frame: 
curr_roll = 0; % range [-180, 180] degrees
%distance of ASV to desired way-point
curr_wp = [0,0]; % current position of ASV -- x and y coordinates in meters 


%SETPOINTS:
% desired roll angle for ASV in body fixed frame:
setpt_roll = 0; % range [-45, 45] degrees
setpt_wp = [0,0]; % desired way-point x and y coordinates in meters 


%OUTPUTS:
% output to motors -- unit can be in Newtons, or RPMs, or duty-factor of a
% pulse
op_roll = 0; % range [-Fmax/5, Fmax/5]  % where Fmax is the maximum force that can be generated by the propellers (unit in Newtons) 
op_throttle = 0; % range [-Fmax, Fmax]  % where Fmax is the maximum force that can be generated by the propellers (unit in Newtons) 

%it is upto the user to make sure the inputs, setpoints and outputs are
%within the desired range, and to clamp them if they are not.

% Sample time
%Dictates how oftern the PID controller is sampled
sample_time = 0.01; % unit is in seconds


% Parameters of the PID controller to be tuned are kp_roll, ki_roll and kd_roll; these
% need to be set by the user or optimized with a ML algorithm
% Scale ki_roll and kd_roll with respect to the sample time
ki_roll = ki_roll * sample_time;
kd_roll = kd_roll / sample_time;

% Same for kp_throttle, ki_throttle and kd_throttle
ki_throttle = ki_throttle * sample_time;
kd_throttle = kd_throttle / sample_time;

integration_roll_error = 0;
prev_roll_error = 0;
integration_throttle_error = 0;
prev_throttle_error = 0;
for t=0:sample_time:200000

    % At each control-cycle t
    % get curr_roll from the ASV IMU sensors
    % get setpt_roll from the tele-operator or the high-level controller  
    roll_error = (setpt_roll - curr_roll);
    integration_roll_error = integration_roll_error + ki_roll * roll_error;  
    % clamp integration_roll_error to be in pre-set range   
    differential_roll_error = roll_error - prev_roll_error;
    op_roll = kp * roll_error + integration_roll_error + kd_roll * differential_roll_error;
    prev_roll_error = roll_error;
    % clamp op_roll to be in pre-set range
    
    % At each control-cycle t
    % get curr_wp from the ASV GPS sensor
    % get setpt_wp from the tele-operator or the high-level controller  
    throttle_error = distance(setpt_wp - curr_wp);
    integration_throttle_error = integration_throttle_error + ki_throttle * throttle_error;  
    % clamp integration_throttle_error to be in pre-set range   
    differential_throttle_error = throttle_error - prev_throttle_error;
    op_throttle = kp * throttle_error + integration_throttle_error + kd_throttle * differential_throttle_error;
    prev_throttle_error = throttle_error;
    % clamp op_throttle to be in pre-set range    
    
    m1 = -op_throttle + op_roll;
    m2 = -op_throttle - op_roll;
    m3 = op_throttle - op_roll;
    m4 = op_throttle + op_roll;    
end






