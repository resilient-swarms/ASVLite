#pragma once

#include "geometry.h"
#include "sea_surface.h"
#include <Eigen/Dense>
#include <vector>
#include <memory>


namespace ASVLite {

    /**
     * @brief Geometric specifications of an Autonomous Surface Vehicle (ASV).
     */
    struct AsvSpecification {
        /** @brief Length at waterline (in meters). */
        const double L_wl;

        /** @brief Breadth at waterline (in meters). */
        const double B_wl;

        /** @brief Depth of the ASV hull (in meters). */
        const double D;

        /** @brief Draught of the ASV (in meters). */
        const double T;
    };



    /**
     * @brief Structure representing the rigid body dynamics of an Autonomous Surface Vehicle (ASV).
     * 
     * This struct holds time, pose, hydrodynamic properties, and dynamic state variables used for 
     * simulating the 6-DOF motion of the ASV in a marine environment.
     */
    struct AsvDynamics {
        /** @brief Simulation time (in seconds). */
        double time = 0.0;

        /** @brief Time step size (in milliseconds). */
        const double time_step_size = 40;

        /**
         * @brief Position of the ASV in 3D space (in meters).
         * 
         * The origin is at the midpoint of the vehicle's still-waterline position.
         */
        Geometry::Coordinates3D position;

        /** @brief Attitude of the ASV (roll, pitch, yaw in radians). 
         * @note Internally, yaw is measured counterclockwise from the East (i.e., the positive X-axis),
         * but for the class interface, yaw is represented as clockwise from North (i.e., the positive Y-axis).
         */
        Geometry::Coordinates3D attitude;

        /** @brief Depth of submersion of the ASV (in meters). */
        double submersion_depth;

        /** @brief Mass and added mass matrix (6×6) in kilograms. */
        Eigen::Matrix<double, 6, 6> M = Eigen::Matrix<double, 6, 6>::Zero();

        /** @brief Damping (drag) coefficient matrix (6×6). */
        Eigen::Matrix<double, 6, 6> C = Eigen::Matrix<double, 6, 6>::Zero();

        /** @brief Hydrostatic stiffness matrix (6×6). */
        Eigen::Matrix<double, 6, 6> K = Eigen::Matrix<double, 6, 6>::Zero();

        /** @brief Displacement (deflection) in body-fixed frame (6×1). */
        Eigen::Matrix<double, 6, 1> X = Eigen::Matrix<double, 6, 1>::Zero();

        /** @brief Velocity in body-fixed frame (6×1). */
        Eigen::Matrix<double, 6, 1> V = Eigen::Matrix<double, 6, 1>::Zero();

        /** @brief Acceleration in body-fixed frame (6×1). */
        Eigen::Matrix<double, 6, 1> A = Eigen::Matrix<double, 6, 1>::Zero();

        /** @brief Total net force acting on the ASV (6×1). */
        Eigen::Matrix<double, 6, 1> F = Eigen::Matrix<double, 6, 1>::Zero();

        /** @brief Wave-induced force (6×1). */
        Eigen::Matrix<double, 6, 1> F_wave = Eigen::Matrix<double, 6, 1>::Zero();

        /** @brief Force generated by the ASV’s thrusters (6×1). */
        Eigen::Matrix<double, 6, 1> F_thrust = Eigen::Matrix<double, 6, 1>::Zero();

        /** @brief Hydrodynamic drag (quadratic) force (6×1). */
        Eigen::Matrix<double, 6, 1> F_drag = Eigen::Matrix<double, 6, 1>::Zero();

        /** @brief Hydrostatic restoring force (6×1). */
        Eigen::Matrix<double, 6, 1> F_restoring = Eigen::Matrix<double, 6, 1>::Zero();
    };



    /**
     * @brief Represents an Autonomous Surface Vehicle (ASV) operating in a sea environment.
     * 
     * @tparam N Number of regular component waves used to model the wave spectrum.
     */
    template<size_t N> 
    class Asv {

        public:

            /**
             * @brief Constructs an Autonomous Surface Vehicle (ASV) in a given sea environment.
             * 
             * Initializes the ASV's position and attitude, adjusting vertical placement based on 
             * sea surface elevation and normalising orientation angles.
             * 
             * @param spec ASV geometric specifications.
             * @param sea_surface Pointer to the irregular sea surface model (must not be nullptr).
             * @param position Initial position of the ASV on the sea surface (in meters).
             * @param attitude Initial attitude of the ASV (roll, pitch, yaw in radians, yaw is w.r.t. geographic north).
             * 
             * @throws std::invalid_argument if sea_surface is a nullptr.
             */
            Asv(const AsvSpecification& spec, 
                const SeaSurface<N>* sea_surface, 
                const Geometry::Coordinates3D& position, 
                const Geometry::Coordinates3D& attitude) :
            spec {spec} {
                if(sea_surface == nullptr) {
                    throw std::invalid_argument("Sea surface cannot be nullptr.");
                }
                this->sea_surface = sea_surface;
                // Place the asv vertically in the correct position W.R.T sea_surface
                dynamics.position = position;
                dynamics.position.keys.z = sea_surface->get_elevation(position, dynamics.time);
                dynamics.attitude.keys.x = Geometry::normalise_angle_PI(attitude.keys.x);
                dynamics.attitude.keys.y = Geometry::normalise_angle_PI(attitude.keys.y);
                // Note: yaw is provided as w.r.t North. Chage it to w.r.t East (x-axis) so as to match the intrinsic Z-Y-X rotation sequence.
                dynamics.attitude.keys.z = Geometry::switch_angle_frame(attitude.keys.z);
            }
            

            /**
             * @brief Advances the ASV simulation by one time step using the specified thrust input.
             * 
             * @param thrust_position Point of thrust application in body-fixed coordinates.
             * @param thrust_magnitude Vector representing the magnitude and direction of applied thrust.
             */
            void step_simulation(const Geometry::Coordinates3D& thrust_position, const Geometry::Coordinates3D& thrust_magnitude) {
                // Advance time
                dynamics.time += dynamics.time_step_size/1000.0; // seconds
                // Update submersion depth based on the ASV's vertical position relative to the current sea surface elevation and draught.
                dynamics.submersion_depth = (dynamics.position.keys.z - spec.T) - sea_surface->get_elevation(dynamics.position, dynamics.time);
                // Update vehicle dynamics
                set_mass();
                set_wave_force();
                set_thrust(thrust_position, thrust_magnitude);
                set_drag_force();
                set_restoring_force();
                set_net_force();
                set_acceleration();
                set_velocity();
                set_deflection();
                set_pose();
            }
            

            /**
             * @brief Updates the ASV to operate under a new sea state.
             * 
             * This function replaces the current sea surface model with a new one and 
             * adjusts the ASV's vertical position to preserve its original submersion depth
             * relative to the wave elevation at its location.
             * 
             * @param sea_surface Pointer to the new sea surface model (must not be nullptr).
             * 
             * @throws std::invalid_argument if the provided sea_surface is a nullptr.
             */
            void set_sea_state(const SeaSurface<N>* sea_surface) { 
                if(sea_surface == nullptr) {
                    throw std::invalid_argument("Sea surface cannot be nullptr.");
                }
                // Calculate the current submersion depth before changing the sea surface
                const double vertical_position_error = sea_surface->get_elevation(dynamics.position, dynamics.time) - dynamics.position.keys.z;
                // set the sea_surface for the ASV
                this->sea_surface = sea_surface;
                // Place the asv vertically in the correct position W.R.T new sea_surface
                dynamics.position.keys.z = sea_surface->get_elevation(dynamics.position, dynamics.time) + vertical_position_error;
            }


            /**
             * @brief Updates the ocean current affecting the ASV.
             * 
             * @param ocean_current A pair representing the ocean current:
             *        - first: zonal (east-west) velocity component (in m/s),
             *        - second: meridional (north-south) velocity component (in m/s).
             */
            void set_ocean_current(const std::pair<double, double>& ocean_current) {
                this->ocean_current = ocean_current;
            }


            /**
             * @brief Enables or disables halting of surge and sway motions of the ASV.
             * 
             * When set to true, the ASV's surge (longitudinal) and sway (lateral) motions are frozen.
             * The remaining four degrees of freedom (heave, roll, pitch, yaw) remain unaffected.
             * 
             * @param set_halt Boolean flag to enable (true) or disable (false) surge and sway halt.
             */
            void set_surge_sway_halt(bool set_halt) {
                halt_surge_and_sway = set_halt;
            }


            /**
             * @brief Retrieves the current sea surface model associated with the ASV.
             * 
             * @return Pointer to the current SeaSurface instance.
             */
            const SeaSurface<N>* get_sea_surface() const {
                return sea_surface;
            }


            /**
             * @brief Returns the current position of the ASV in 3D space.
             * 
             * @return Geometry::Coordinates3D Position coordinates (in meters).
             */
            Geometry::Coordinates3D get_position() const {
                return dynamics.position;
            }


            /**
             * @brief Returns the current attitude of the ASV in 3D space.
             * 
             * The yaw angle is converted from the internal East-referenced frame 
             * to a North-referenced frame before returning.
             * 
             * @return Geometry::Coordinates3D Attitude (roll, pitch, yaw in radians).
             */
            Geometry::Coordinates3D get_attitude() const {
                Geometry::Coordinates3D attitude = dynamics.attitude;
                attitude.keys.z = Geometry::switch_angle_frame(attitude.keys.z); // Convert yaw from w.r.t East to w.r.t North.
                return dynamics.attitude;
            }


            /**
             * @brief Returns the submersion depth of the ASV's lowest point relative to the sea surface.
             * 
             * A negative value indicates submersion below the waterline, while a positive value 
             * indicates that the vehicle is above the waterline (out of the water).
             * 
             * @return double Submersion depth in meters.
             */
            double get_submersion_depth() const {
                return dynamics.submersion_depth;
            }


            /**
             * @brief Returns the simulation time elapsed since the start.
             * 
             * @return double Time in seconds since the beginning of the simulation.
             */
            double get_time() const {
                return dynamics.time;
            }


            /**
             * @brief Returns the time step size used in the simulation.
             * 
             * @return double Time step size in milliseconds.
             */
            double get_time_step_size() const {
                return dynamics.time_step_size;
            }


            /**
             * @brief Returns the wave-induced force acting on the ASV at the current simulation time.
             * 
             * The force is represented as a 6-DOF vector (surge, sway, heave, roll, pitch, yaw) in Newtons.
             * 
             * @return Geometry::RigidBodyDOF Wave force vector in N.
             */
            Geometry::RigidBodyDOF get_wave_force() const {
                Geometry::RigidBodyDOF force;
                for(size_t i = 0; i < Geometry::COUNT_DOF; ++i){
                    force.array[i] = dynamics.F_wave(i);
                }
                return force;
            }


            /**
             * @brief Returns the hydrodynamic drag force acting on the ASV at the current simulation time.
             * 
             * The force is expressed as a 6-DOF vector (surge, sway, heave, roll, pitch, yaw) in Newtons.
             * 
             * @return Geometry::RigidBodyDOF Drag force vector in N.
             */
            Geometry::RigidBodyDOF get_drag_force() const {
                Geometry::RigidBodyDOF force;
                for(size_t i = 0; i < Geometry::COUNT_DOF; ++i){
                    force.array[i] = dynamics.F_drag(i);
                }
                return force;
            }


            /**
             * @brief Returns the hydrostatic restoring force acting on the ASV at the current simulation time.
             * 
             * The restoring force opposes displacement and is expressed as a 6-DOF vector 
             * (surge, sway, heave, roll, pitch, yaw) in Newtons.
             * 
             * @return Geometry::RigidBodyDOF Restoring force vector in N.
             */
            Geometry::RigidBodyDOF get_restoring_force() const {
                Geometry::RigidBodyDOF force;
                for(size_t i = 0; i < Geometry::COUNT_DOF; ++i){
                    force.array[i] = dynamics.F_restoring(i);
                }
                return force;
            }


            /**
             * @brief Returns the propulsive thrust force acting on the ASV at the current simulation time.
             * 
             * The thrust is represented as a 6-DOF vector (surge, sway, heave, roll, pitch, yaw) in Newtons.
             * 
             * @return Geometry::RigidBodyDOF Propulsive thrust vector in N.
             */
            Geometry::RigidBodyDOF get_propulsive_thrust() const {
                Geometry::RigidBodyDOF force;
                for(size_t i = 0; i < Geometry::COUNT_DOF; ++i){
                    force.array[i] = dynamics.F_thrust(i);
                }
                return force;
            }


            /**
             * @brief Returns the net force acting on the ASV at the current simulation time.
             * 
             * The net force is the sum of all contributing forces (e.g., wave, thrust, drag, restoring) 
             * and is represented as a 6-DOF vector (surge, sway, heave, roll, pitch, yaw) in Newtons.
             * 
             * @return Geometry::RigidBodyDOF Net force vector in N.
             */
            Geometry::RigidBodyDOF get_net_force() const {
                Geometry::RigidBodyDOF force;
                for(size_t i = 0; i < Geometry::COUNT_DOF; ++i){
                    force.array[i] = dynamics.F(i);
                }
                return force;
            }


            /**
             * @brief Returns the current acceleration of the ASV.
             * 
             * The acceleration is expressed as a 6-DOF vector (surge, sway, heave, roll, pitch, yaw) 
             * in meters per second squared (m/s2 and rad/s2).
             * 
             * @return Geometry::RigidBodyDOF Acceleration vector in m/s2.
             */
            Geometry::RigidBodyDOF get_acceleration() const {
                Geometry::RigidBodyDOF acceleration;
                for(size_t i = 0; i < Geometry::COUNT_DOF; ++i){
                    acceleration.array[i] = dynamics.A(i);
                }
                return acceleration;
            }


            /**
             * @brief Returns the current velocity of the ASV.
             * 
             * The velocity is expressed as a 6-DOF vector (surge, sway, heave, roll, pitch, yaw),
             * in meters per second (m/s) for translational and radians per second (rad/s) for rotational components.
             * 
             * @return Geometry::RigidBodyDOF Velocity vector.
             */
            Geometry::RigidBodyDOF get_velocity() const {
                Geometry::RigidBodyDOF velocity;
                for(size_t i = 0; i < Geometry::COUNT_DOF; ++i){
                    velocity.array[i] = dynamics.V(i);
                }
                return velocity;
            }


            /**
             * @brief Returns the mass and added mass terms for each degree of freedom.
             * 
             * Extracts the diagonal elements of the 6×6 mass matrix, representing the effective mass 
             * (including added mass) in each DOF: surge, sway, heave, roll, pitch, yaw.
             * 
             * @return Geometry::RigidBodyDOF Mass values in kg (for linear DOFs) and kg·m2 (for rotational DOFs).
             */
            Geometry::RigidBodyDOF get_mass() const {
                Geometry::RigidBodyDOF mass;
                for(size_t i = 0; i < Geometry::COUNT_DOF; ++i){
                    mass.array[i] = dynamics.M(i,i);
                }
                return mass;
            }


            /**
             * @brief Returns the geometric specification of the ASV.
             * 
             * @return AsvSpecification Struct containing length, breadth, depth, and draught of the ASV.
             */
            AsvSpecification get_spec() const {
                return spec;
            }


        private:

            /**
             * @brief Computes the wave encounter frequency for a moving ASV.
             * 
             * Calculates the frequency at which the ASV encounters each wave component,
             * accounting for vehicle speed and relative wave heading.
             * 
             * @param asv_speed Forward speed of the ASV (in m/s).
             * @param wave_freq Vector of wave frequencies (in Hz).
             * @param relative_wave_heading Vector of relative wave headings (in radians) with respect to the ASV's heading.
             * 
             * @return Eigen::Vector<double, N> Encounter frequencies (in Hz) for each wave component.
             */
            Eigen::Vector<double, N> get_encounter_frequency(double asv_speed, Eigen::Vector<double, N> wave_freq, Eigen::Vector<double, N> relative_wave_heading) {
                return wave_freq.array() - (wave_freq.array().square()/ASVLite::Constants::G) * asv_speed * relative_wave_heading.array().cos();
            }


            /**
             * @brief Computes the submerged volume of the ASV based on its submersion depth.
             * 
             * Assumes the submerged portion of the ASV is shaped as a hemi-ellipsoid. The submersion 
             * depth must be negative (i.e., below the waterline) and is clamped between 0 and -D.
             * 
             * @param submersion_depth Vertical distance from the waterline to the ASV's lowest point (in meters, should be negative).
             * @return double Submerged volume in cubic meters (m3).
             */
            double get_submerged_volume(const double submersion_depth) const { // NOTE: submerged depth should be -ve.
                // Assuming a hemi-ellipsoid shape for the submerged part of the ASV
                const double d = -std::clamp(submersion_depth, -spec.D, 0.0);
                double volume = M_PI/6.0 * spec.L_wl * spec.B_wl * d * (3.0 - d/spec.D);
                return volume;
            }


            /**
             * @brief Computes the added mass coefficient for the ASV based on its length-to-breadth ratio.
             * 
             * The coefficient is estimated using linear interpolation from a lookup table 
             * derived from DNVGL-RP-N103 (Table A-2, page 209), assuming an elliptical waterplane shape.
             * 
             * @return double Added mass coefficient (dimensionless).
             * 
             * @note If the length-to-breadth ratio is outside the tabulated range, the function returns 
             *       the nearest available value. The table assumes idealised hull geometries.
             */
            double get_added_mass_coeff() const {
                // Ref: DNVGL-RP-N103 Table A-2 (page 209)
                // Waterplane is assumed to be elliptical.
                // Define the table of b/a and CA values
                std::vector<std::pair<double, double>> table = {
                    {std::numeric_limits<double>::infinity(), 1.0},
                    {14.3, 0.991},
                    {12.8, 0.989},
                    {10.0, 0.984},
                    {7.0, 0.972},
                    {6.0, 0.964},
                    {5.0, 0.952},
                    {4.0, 0.933},
                    {3.0, 0.9},
                    {2.0, 0.826},
                    {1.5, 0.758},
                    {1.0, 0.637}
                };
                // Check if ba is within bounds
                const double ba = spec.L_wl / spec.B_wl;
                if (ba >= table.front().first) return table.front().second;
                if (ba <= table.back().first) return table.back().second;
                // Find the correct interval and interpolate
                for (size_t i = 0; i < table.size() - 1; ++i) {
                    if (ba <= table[i].first && ba >= table[i + 1].first) {
                        const double ba1 = table[i].first; 
                        const double ba2 = table[i + 1].first;
                        const double CA1 = table[i].second; 
                        const double CA2 = table[i + 1].second;
                        return CA1 + (CA2 - CA1) * ((ba - ba1) / (ba2 - ba1));
                    }
                }
                return -1; // Should not reach here
            }


            /**
             * @brief Estimates the drag coefficient for flow parallel to a submerged body's major axis.
             * 
             * The coefficient is determined by interpolating values from DNVGL-RP-N103 (Table B-1, page 215),
             * assuming the body has an elliptical cross-section. The function uses the ratio of the
             * dimension perpendicular to the flow (`d`) and the dimension along the flow (`l`).
             * 
             * @param l Length of the body along the direction of flow (in meters).
             * @param d Characteristic dimension perpendicular to the flow (in meters).
             * 
             * @return double Drag coefficient for parallel flow (dimensionless).
             * 
             * @note If the d/l ratio falls outside the tabulated range, the closest boundary value is returned.
             */
            double get_drag_coefficient_parallel_flow(const double l, const double d) const {
                // Ref: DNVGL-RP-N103 Table B-1 (page 215)
                // Waterplane is assumed to be elliptical.
                // Define the table of d/l and C_ds values
                std::vector<std::pair<double, double>> table = {
                    {0.125, 0.22},
                    {0.25, 0.3},
                    {0.5, 0.6},
                    {1.0, 1.0},
                    {2.0, 1.6},
                };
                // Check if ba is within bounds
                const double dl = d / l;
                if (dl >= table.front().first) return table.front().second;
                if (dl <= table.back().first) return table.back().second;
                // Find the correct interval and interpolate
                for (size_t i = 0; i < table.size() - 1; ++i) {
                    if (dl <= table[i].first && dl >= table[i + 1].first) {
                        const double dl1 = table[i].first; 
                        const double dl2 = table[i + 1].first;
                        const double Cds1 = table[i].second; 
                        const double Cds2 = table[i + 1].second;
                        return Cds1 + (Cds2 - Cds1) * ((dl - dl1) / (dl2 - dl1));
                    }
                }
                return -1; // Should not reach here
            }

            
            /**
             * @brief Estimates the drag coefficient for flow perpendicular to a submerged body's major axis.
             * 
             * The coefficient is determined using values from DNVGL-RP-N103 (Table B-2, page 217),
             * assuming a rectangular cross-section. It is based on the ratio of the longer edge (`b`)
             * to the shorter edge (`h`) of the body’s cross-section.
             * 
             * @param b Length of the longer edge perpendicular to flow (in meters).
             * @param h Length of the shorter edge perpendicular to flow (in meters).
             * 
             * @return double Drag coefficient for perpendicular flow (dimensionless).
             * 
             * @note If the b/h ratio falls outside the table range, the nearest boundary value is returned.
             */
            double get_drag_coefficient_prependicular_flow(const double b, const double h) const { // b --> longer edge, h --> short edge.
                // Ref: DNVGL-RP-N103 Table B-2 (page 217)
                // Waterplane is assumed to be rectangular.
                // Define the table of b/h and C_ds values
                std::vector<std::pair<double, double>> table = {
                    {1.0, 1.16},
                    {5.0, 1.2},
                    {10.0, 1.5},
                    {std::numeric_limits<double>::infinity(), 1.9},
                };
                // Check if ba is within bounds
                const double bh = b / h;
                if (bh >= table.front().first) return table.front().second;
                if (bh <= table.back().first) return table.back().second;
                // Find the correct interval and interpolate
                for (size_t i = 0; i < table.size() - 1; ++i) {
                    if (bh <= table[i].first && bh >= table[i + 1].first) {
                        const double bh1 = table[i].first; 
                        const double bh2 = table[i + 1].first;
                        const double Cds1 = table[i].second; 
                        const double Cds2 = table[i + 1].second;
                        return Cds1 + (Cds2 - Cds1) * ((bh - bh1) / (bh2 - bh1));
                    }
                }
                return -1; // Should not reach here
            }

            
            /**
             * @brief Computes and sets the mass and added mass matrix for the ASV.
             * 
             * This function calculates the rigid body mass and moments of inertia based on the ASV’s
             * submerged geometry, assuming an elliptical waterplane and hemi-ellipsoidal submerged shape.
             * It also computes added mass terms for heave, roll, and pitch based on encounter frequency,
             * wave characteristics, and empirical coefficients.
             * 
             * The following components are computed and assigned to the mass matrix:
             * - **Rigid body mass** from submerged volume and seawater density.
             * - **Moments of inertia** (roll, pitch, yaw) using standard formulas for ellipsoidal bodies.
             * - **Added mass** (heave, roll, pitch) from wave encounter frequency and empirical coefficients.
             * 
             * @throws std::runtime_error If the computed added mass coefficient is invalid.
             * 
             * @note Added mass is only applied to oscillatory DOFs (heave, roll, pitch); surge, sway,
             *       and yaw added masses are currently set to zero.
             * 
             * @ref DNVGL-RP-N103 for added mass coefficient reference.
             */
            void set_mass() {
                // Mass of the ASV
                const double submerged_volume = get_submerged_volume(-spec.T);
                const double asv_mass = submerged_volume * Constants::SEA_WATER_DENSITY;
                // Moment of inertia for angular motions considering an elliptical waterplane.
                const double I_roll =  (1.0 / 20.0) * asv_mass * (spec.B_wl*spec.B_wl + spec.T*spec.T); // Roll
                const double I_pitch = (1.0 / 20.0) * asv_mass * (spec.L_wl*spec.L_wl + spec.T*spec.T);  // Pitch
                const double I_yaw =   (1.0 / 20.0) * asv_mass * (spec.L_wl*spec.L_wl + spec.B_wl*spec.B_wl);  // Yaw
                // Added mass of the ASV - only associated with oscillatory motions.
                const double added_mass_surge = 0.0;
                const double added_mass_sway  = 0.0;
                const double added_mass_yaw = 0.0;
                // Added mass coeffient
                const double C_linear = get_added_mass_coeff();
                if(C_linear < 0.0) {
                    throw std::runtime_error("Invalid added mass coefficient");
                }
                const double V_r = M_PI/6.0 * spec.B_wl*spec.B_wl * spec.L_wl;
                const double C_angular = 0.2;
                // Encounter frequency 
                const Eigen::Vector<double, N> relative_wave_heading = (sea_surface->component_waves.heading.array() - dynamics.attitude.keys.z).unaryExpr(&Geometry::normalise_angle_PI);
                const Eigen::Vector<double, N> encounter_freq = get_encounter_frequency(dynamics.V(0,0), sea_surface->component_waves.frequency, relative_wave_heading);
                // Added mass for heave, pitch and roll
                double added_mass_heave = (encounter_freq.array().square() / N * C_linear * Constants::SEA_WATER_DENSITY * V_r).sum();
                double added_mass_roll  = (encounter_freq.array().square() / N * C_angular * Constants::SEA_WATER_DENSITY * submerged_volume * (spec.B_wl*spec.B_wl + spec.T*spec.T)/5.0).sum();
                double added_mass_pitch = (encounter_freq.array().square() / N * C_angular * Constants::SEA_WATER_DENSITY * submerged_volume * (spec.L_wl*spec.L_wl + spec.T*spec.T)/5.0).sum();
                // Set the mass matrixs
                dynamics.M(0, 0) = asv_mass + added_mass_surge;
                dynamics.M(1, 1) = asv_mass + added_mass_sway;
                dynamics.M(2, 2) = asv_mass + added_mass_heave;
                dynamics.M(3, 3) = I_roll   + added_mass_roll;
                dynamics.M(4, 4) = I_pitch  + added_mass_pitch;
                dynamics.M(5, 5) = I_yaw    + added_mass_yaw;
            }


            /**
             * @brief Computes and sets the hydrodynamic drag coefficients for all six degrees of freedom.
             * 
             * This function calculates quadratic drag coefficients for surge, sway, heave, roll, pitch,
             * and yaw using empirical formulations and references:
             * 
             * - **Surge & Sway:** Based on parallel flow drag using elliptical waterplane assumptions,
             *   from DNVGL-RP-N103 (Table B-1).
             * - **Heave:** Modeled as a flat plate perpendicular to flow, using coefficients from 
             *   DNVGL-RP-N103 (Table B-2).
             * - **Roll, Pitch, Yaw:** Estimated using empirical formulas for damping from the
             *   "Handbook of Marine Craft Hydrodynamics and Motion Control" (p. 125).
             * 
             * @note The drag coefficient matrix `C` is diagonal and populated with corresponding
             *       force coefficients for each DOF. Submersion depth is clamped between 0 and -D.
             * 
             * @ref DNVGL-RP-N103, Appendix B, Tables B-1 and B-2.  
             * @ref Handbook of Marine Craft Hydrodynamics and Motion Control, p. 125.
             */
            void set_drag_coefficient() {
                // Ref: Recommended practices DNVGL-RP-N103 Modelling and analysis of marine
                // operations. Edition July 2017. Appendix B Table B-1, B-2.
                // Surge drag coefficient - assuming elliptical waterplane area
                const double c = -std::clamp(dynamics.submersion_depth, -spec.D, 0.0);
                const double C_DS_surge = get_drag_coefficient_parallel_flow(spec.L_wl, spec.B_wl);
                const double C_DS_sway  = get_drag_coefficient_parallel_flow(spec.B_wl, spec.L_wl);
                const double C_surge = 0.5 * Constants::SEA_WATER_DENSITY * C_DS_surge * spec.B_wl * c;
                const double C_sway  = 0.5 * Constants::SEA_WATER_DENSITY * C_DS_sway  * spec.L_wl * c;
                // Heave drag coefficient - consider it as flat plat perpendicular to flow.
                const double C_DS_heave = get_drag_coefficient_prependicular_flow(spec.L_wl, spec.B_wl);
                const double C_heave  = 0.5 * Constants::SEA_WATER_DENSITY * C_DS_heave  * spec.L_wl * spec.B_wl;
                // roll, pitch and yaw drag coefficient set equal to roll damping coefficient 
                // given in Handbook of Marin Craft Hydrodynamics and motion control, page 125
                const double C_roll  = 1.5 * Constants::SEA_WATER_DENSITY * spec.B_wl*spec.B_wl*spec.B_wl * spec.T;
                const double C_pitch = 1.5 * Constants::SEA_WATER_DENSITY * spec.L_wl*spec.L_wl*spec.L_wl * spec.T;
                const double C_yaw   = 1.5 * Constants::SEA_WATER_DENSITY * spec.B_wl*spec.B_wl*spec.B_wl * spec.L_wl;
                // Set the drage coeff matrix
                dynamics.C(0, 0) = C_surge;
                dynamics.C(1, 1) = C_sway;
                dynamics.C(2, 2) = C_heave;
                dynamics.C(3, 3) = C_roll;
                dynamics.C(4, 4) = C_pitch;
                dynamics.C(5, 5) = C_yaw;
            }


            /**
             * @brief Computes and sets the hydrostatic stiffness matrix for the ASV.
             * 
             * This function calculates the restoring (stiffness) coefficients for the heave, roll, 
             * and pitch degrees of freedom based on the ASV’s submerged waterplane geometry. 
             * Surge, sway, and yaw stiffness terms are assumed to be zero.
             * 
             * - **Heave:** Computed from the submerged waterplane area and displaced fluid weight.
             * - **Roll & Pitch:** Based on second moments of area (I_xx, I_yy) of the elliptical waterplane 
             *   and hydrostatic pressure distribution.
             * 
             * Waterplane geometry is approximated as an ellipse, and the vertical position is clamped 
             * to the valid submersion range.
             * 
             * @ref Dynamics of Marine Vehicles, R. Bhattacharyya, page 66 (for roll and pitch stiffness).
             * 
             * @note The stiffness matrix `K` is diagonal. Surge, sway, and yaw are set to zero as 
             *       hydrostatic restoring forces in these directions are negligible.
             */
            void set_stiffness() {
                constexpr double K_surge = 0.0;
                constexpr double K_sway  = 0.0;
                constexpr double K_yaw   = 0.0;
                // Assuming elliptical shape for the water plane area.
                // Get the dimensions of the ellipse for the waterplane at the given submersion depth.
                const double c = -std::clamp(dynamics.submersion_depth, -spec.D, 0.0);
                const double a = spec.L_wl/2.0 * sqrt(1 - (spec.D - c)/spec.D);
                const double b = spec.B_wl/2.0 * sqrt(1 - (spec.D - c)/spec.D);
                const double A = M_PI * a * b;
                const double I_xx = M_PI/16.0 * a * pow(b, 3);
                const double I_yy = M_PI/16.0 * b * pow(a, 3);
                // Heave stiffness
                double K_heave = A * Constants::SEA_WATER_DENSITY * Constants::G;
                // Roll stiffness
                // Using the same formula as mentioned for pitch in below ref.
                // Ref: Dynamics of Marine Vehicles, R. Bhattacharyya, page 66
                const double K_roll = I_xx * Constants::SEA_WATER_DENSITY * Constants::G;
                // Pitch stiffness
                // Ref: Dynamics of Marine Vehicles, R. Bhattacharyya, page 66
                const double K_pitch = I_yy * Constants::SEA_WATER_DENSITY * Constants::G;
                // Set the stiffeness matrix
                dynamics.K(0, 0) = K_surge;
                dynamics.K(1, 1) = K_sway;
                dynamics.K(2, 2) = K_heave;
                dynamics.K(3, 3) = K_roll;
                dynamics.K(4, 4) = K_pitch;
                dynamics.K(5, 5) = K_yaw;
            }


            /**
             * @brief Computes and sets the wave-induced force acting on the ASV.
             * 
             * This function estimates the wave excitation forces based on the ASV’s position, 
             * attitude, and the encountered wave spectrum. It models wave pressure using linear wave theory 
             * and applies the force contributions across key points on the ASV hull (center, forward, aft, 
             * starboard, and portside).
             * 
             * Key steps in the computation:
             * - Computes the waterplane geometry assuming an elliptical shape based on submersion depth.
             * - Computes world-frame positions of key points using intrinsic Z-Y-X (yaw–pitch–roll) rotation.
             * - Calculates wave pressures at these points using the encountered wave spectrum (adjusted for encounter frequency).
             * - Computes vertical and rotational force components (heave, roll, pitch) from distributed pressure fields.
             * 
             * @note 
             * - Force contributions in surge, sway, and yaw directions are currently commented out.
             * - Submersion depth is clamped to ensure valid waterplane dimensions.
             * - Only applied if the ASV is submerged (negative submersion depth).
             * 
             * @ref DNVGL-RP-N103 and linear wave theory for wave pressure calculations.
             */
            void set_wave_force() {
                // Assuming elliptical shape for the water plane area.
                // Get the dimensions of the ellipse for the waterplane at the given submersion depth.
                const double c = -std::clamp(dynamics.submersion_depth, -spec.D, 0.0);
                const double a = spec.L_wl/2.0 * sqrt(1 - (spec.D - c)/spec.D);
                const double b = spec.B_wl/2.0 * sqrt(1 - (spec.D - c)/spec.D);
                const double A_trans = M_PI/2.0 * b * c;
                const double A_profile = M_PI/2.0 * a * c;
                const double A_waterplane = M_PI/2 * a * b;
                // Reset the wave force to all zeros
                dynamics.F_wave = Eigen::Matrix<double, 6, 1>::Zero();
                if(dynamics.submersion_depth >= 0.0) {
                    dynamics.F_wave = Eigen::Matrix<double, 6, 1>::Zero();
                } else {
                    // Compute the coordinates of fore, aft, port side, starboard side and centre position of the vehicle for calculating wave pressure.
                    // Step 1: Create rotation matrix (intrinsic Z-Y-X: yaw -> pitch -> roll)
                    const Eigen::Matrix3d R (Eigen::AngleAxisd(dynamics.attitude.keys.z, Eigen::Vector3d::UnitZ())*  // yaw  
                                             Eigen::AngleAxisd(dynamics.attitude.keys.y, Eigen::Vector3d::UnitY())*  // pitch 
                                             Eigen::AngleAxisd(dynamics.attitude.keys.x, Eigen::Vector3d::UnitX())); // roll 
                    // Step 2: Define the direction vectors in the body frame
                    const Eigen::Vector3d forward_direction_local_frame(1.0, 0.0, 0.0);
                    const Eigen::Vector3d aft_direction_local_frame(-1.0, 0.0, 0.0);
                    const Eigen::Vector3d starboard_direction_local_frame(0.0, 1.0, 0.0);
                    const Eigen::Vector3d portside_direction_local_frame(1.0, -1.0, 0.0);
                    // Step 3: Rotate direction vectors into world frame
                    const Eigen::Vector3d forward_direction_world_frame   = R * forward_direction_local_frame;
                    const Eigen::Vector3d aft_direction_world_frame       = R * aft_direction_local_frame;
                    const Eigen::Vector3d starboard_direction_world_frame = R * starboard_direction_local_frame;
                    const Eigen::Vector3d portside_direction_world_frame  = R * portside_direction_local_frame;
                    // Step 4: Compute coordinates of the positions in world frame
                    const Eigen::Vector3d position_centre(dynamics.position.keys.x, dynamics.position.keys.y, dynamics.position.keys.z);
                    const Eigen::Vector3d position_forward   = position_centre + (a/2 * forward_direction_world_frame);
                    const Eigen::Vector3d position_aft       = position_centre + (a/2 * aft_direction_world_frame);
                    const Eigen::Vector3d position_starboard = position_centre + (b/2 * starboard_direction_world_frame);
                    const Eigen::Vector3d position_portside  = position_centre + (b/2 * portside_direction_world_frame);
                    // Construct Coordinate3D objects for these positions
                    const Geometry::Coordinates3D pos_centre{position_centre(0), position_centre(1), position_centre(2)};
                    const Geometry::Coordinates3D pos_forward{position_forward(0), position_forward(1), position_forward(2)};
                    const Geometry::Coordinates3D pos_aft{position_aft(0), position_aft(1), position_aft(2)};
                    const Geometry::Coordinates3D pos_starboard{position_starboard(0), position_starboard(1), position_starboard(2)};
                    const Geometry::Coordinates3D pos_porside{position_portside(0), position_portside(1), position_portside(2)};
                    // For each wave in the wave spectrum, compute the wave pressure force
                    const Eigen::Vector<double, N> relative_wave_heading = (sea_surface->component_waves.heading.array() - dynamics.attitude.keys.z).unaryExpr(&Geometry::normalise_angle_PI);
                    const Eigen::Vector<double, N> encounter_freq = get_encounter_frequency(dynamics.V(0,0), sea_surface->component_waves.frequency, relative_wave_heading);
                    const RegularWave<N> encountered_waves {sea_surface->component_waves.amplitude, encounter_freq, sea_surface->component_waves.phase_lag, sea_surface->component_waves.heading};
                    const Eigen::Vector<double, N> wave_pressure_centre     = encountered_waves.get_wave_pressure(pos_centre    , dynamics.time); 
                    const Eigen::Vector<double, N> wave_pressure_forward    = encountered_waves.get_wave_pressure(pos_forward   , dynamics.time); 
                    const Eigen::Vector<double, N> wave_pressure_aft        = encountered_waves.get_wave_pressure(pos_aft       , dynamics.time); 
                    const Eigen::Vector<double, N> wave_pressure_starboard  = encountered_waves.get_wave_pressure(pos_starboard , dynamics.time); 
                    const Eigen::Vector<double, N> wave_pressure_portside   = encountered_waves.get_wave_pressure(pos_porside   , dynamics.time); 
                    // Lever
                    const double lever_trans = b / 8;
                    const double lever_long  = a / 8;
                    // Set the wave pressue force matrix
                    const double scale = 1.0/N;
                    // dynamics.F_wave(0) += ((wave_pressure_forward - wave_pressure_aft) * A_trans * scale).sum(); // surge
                    // dynamics.F_wave(1) += ((wave_pressure_starboard - wave_pressure_portside) * A_profile * scale).sum(); // sway
                    dynamics.F_wave(2) += (wave_pressure_centre * A_waterplane * scale).sum(); // heave
                    dynamics.F_wave(3) += ((wave_pressure_starboard - wave_pressure_portside) * A_waterplane * lever_trans * scale).sum(); // roll
                    dynamics.F_wave(4) += ((wave_pressure_forward - wave_pressure_aft) * A_waterplane * lever_long * scale).sum(); // pitch
                    // dynamics.F_wave(5) += ((wave_pressure_forward - wave_pressure_aft) * A_profile * lever_long * scale).sum(); // yaw
                } 
            
            }


            /**
             * @brief Computes and sets the propulsive thrust force and moments acting on the ASV.
             * 
             * Applies the specified thrust vector at a given point in the ASV's body-fixed frame,
             * and computes the resulting linear forces and rotational moments around the center of gravity.
             * 
             * Thrust is only applied when the ASV is submerged (i.e., submersion depth is negative).
             * 
             * @param thrust_position Position of the thrust application point in the body-fixed frame (in meters).
             * @param thrust_magnitude Thrust force vector in the body-fixed frame (in Newtons).
             */
            void set_thrust(const Geometry::Coordinates3D& thrust_position, const Geometry::Coordinates3D& thrust_magnitude) {
                // Reset the thrust to all zeros
                dynamics.F_thrust = Eigen::Matrix<double, 6, 1>::Zero();
            
                if(dynamics.submersion_depth < 0.0) {
                    const double x = thrust_position.keys.x;
                    const double y = thrust_position.keys.y;
                    const double z = thrust_position.keys.z;
                    // Compute the moment due to the thrust
                    // Assuming COG is at (0,0,0) in body frame
                    const double M_x = thrust_magnitude.keys.y * z + thrust_magnitude.keys.z * y;
                    const double M_y = thrust_magnitude.keys.x * z + thrust_magnitude.keys.z * x; 
                    const double M_z = thrust_magnitude.keys.x * y + thrust_magnitude.keys.y * x;
                    // Set the thrust matrix
                    dynamics.F_thrust(0) = thrust_magnitude.keys.x;
                    dynamics.F_thrust(1) = thrust_magnitude.keys.y;
                    dynamics.F_thrust(2) = thrust_magnitude.keys.z;
                    dynamics.F_thrust(3) = M_x;
                    dynamics.F_thrust(4) = M_y;
                    dynamics.F_thrust(5) = M_z; 
                }
            }
            
            
            /**
             * @brief Computes and sets the hydrodynamic drag force acting on the ASV.
             * 
             * This function calculates quadratic drag forces for all 6 degrees of freedom using 
             * precomputed drag coefficients and the ASV's current velocity. The drag is modeled 
             * using a quadratic formulation.  
             * 
             * Special handling is applied for the **heave** direction:
             * - Heave drag is computed relative to the vertical velocity of the sea surface.
             * - If the ASV is above water (non-submerged), drag is set to zero.
             * 
             * @note This function internally calls `set_drag_coefficient()` to ensure up-to-date coefficients.
             * 
             * @see set_drag_coefficient()
             */
            void set_drag_force() {
                set_drag_coefficient();
            
                // Compute the quadratic velocity term explicitly to avoid unnecessary temporaries
                Eigen::VectorXd velocity_square = dynamics.V.cwiseProduct(dynamics.V.cwiseAbs());
                // Set the drag force matrix
                dynamics.F_drag = -dynamics.C * velocity_square;
                // For heave the drag should be relative to the water surface velocity
                if(dynamics.submersion_depth >= 0.0) {
                    dynamics.F_drag = Eigen::Matrix<double, 6, 1>::Zero();
                } else {
                    const double sea_surface_elevation_0 = sea_surface->get_elevation(dynamics.position, dynamics.time - dynamics.time_step_size/1000.0);
                    const double sea_surface_elevation_1 = sea_surface->get_elevation(dynamics.position, dynamics.time);
                    const double sea_surface_velocity =  (sea_surface_elevation_1 - sea_surface_elevation_0) / (dynamics.time_step_size/1000.0);
                    dynamics.F_drag(2) = -dynamics.C(2,2) * (dynamics.V(2) - sea_surface_velocity) * std::abs(dynamics.V(2) - sea_surface_velocity);
                }
            }


            /**
             * @brief Computes and sets the hydrostatic restoring force acting on the ASV.
             * 
             * This function calculates the restoring forces in the heave, roll, and pitch directions
             * based on the vehicle's submersion depth and attitude. The restoring force is derived from 
             * the stiffness matrix and the displacement from equilibrium.
             * 
             * Key details:
             * - A 3×3 submatrix of the stiffness matrix is used to compute restoring forces for heave, roll, and pitch.
             * - Restoring forces in surge, sway, and yaw are assumed to be zero.
             * 
             * @note This function internally calls `set_stiffness()` to ensure the stiffness matrix is up to date.
             * 
             * @see set_stiffness()
             */
            void set_restoring_force() {
                set_stiffness();
             
                // Heave restoring force
                const double delta_T = spec.T + dynamics.submersion_depth;
                const Eigen::Vector3d elongation {delta_T, dynamics.attitude.keys.x, dynamics.attitude.keys.y};
                // Set the restoring force matrix
                const Eigen::Matrix3d K_sub = dynamics.K.block<3,3>(2,2); // Extract the relevant 3x3 submatrix from K
                dynamics.F_restoring.segment(2,3) = -K_sub * elongation; // heave, roll, pitch
                // Overwrite the heave restoring force with the buoyancy - weight 
                double buoyancy = get_submerged_volume(dynamics.submersion_depth) * Constants::SEA_WATER_DENSITY * Constants::G;
                double weight = get_submerged_volume(-spec.T) * Constants::SEA_WATER_DENSITY * Constants::G;
                dynamics.F_restoring(2) = buoyancy - weight;
                // No restoring force for sway, yaw and surge.
            }


            /**
             * @brief Computes and sets the net force acting on the ASV.
             * 
             * The net force is calculated as the sum of thrust, wave, drag, and restoring forces.
             * Optionally, the surge and sway components can be zeroed out if motion in those 
             * directions is halted.
             * 
             * @note The `halt_surge_and_sway` flag disables surge and sway forces when set to true.
             */
            void set_net_force() {
                // Set the net force matrix
                dynamics.F = dynamics.F_thrust + dynamics.F_wave + dynamics.F_drag + dynamics.F_restoring;
                if(halt_surge_and_sway) {
                    dynamics.F(0) = 0.0;
                    dynamics.F(1) = 0.0;
                }
            }


            /**
             * @brief Computes and sets the acceleration of the ASV.
             */
            void set_acceleration() {
                // Set acceleration matrix
                dynamics.A = dynamics.M.inverse() * dynamics.F;
            }

            
            /**
             * @brief Computes and sets the velocity of the ASV.
             */
            void set_velocity() {
                // Set velocity matrix
                dynamics.V = dynamics.V + (dynamics.A * dynamics.time_step_size/1000.0);
            }

            
            /**
             * @brief Computes and sets the deflection of the ASV (body-fixed frame) based on its velocity and ocean current.
             * 
             * This function calculates the deflection (displacement) by considering the net velocity of the ASV,
             * including both the vehicle's velocity and the ocean current. The ocean current velocity is first converted from 
             * the global coordinate frame to the body-fixed frame using the vehicle's attitude. Then, the deflection 
             * is computed by integrating the net velocity over the current time step.
             * 
             * The steps involved are:
             * - Compute the ocean current velocity in the body frame.
             * - Add the ocean current's contribution to the ASV's current velocity.
             * - Integrate the velocity over the time step to compute the displacement.
             * 
             * @note The ocean current is only considered in the linear velocity components (X and Y).
             */
            void set_deflection() {
                // Construct a resultant velocity matrix in body frame considering ocean current
                // Create rotation matrix (intrinsic Z-Y-X: yaw -> pitch -> roll)
                const Eigen::Matrix3d R (Eigen::AngleAxisd(dynamics.attitude.keys.z, Eigen::Vector3d::UnitZ())*  // yaw  
                                         Eigen::AngleAxisd(dynamics.attitude.keys.y, Eigen::Vector3d::UnitY())*  // pitch 
                                         Eigen::AngleAxisd(dynamics.attitude.keys.x, Eigen::Vector3d::UnitX())); // roll 
                // Global velocity in world frame (only X and Y are given)
                const Eigen::Vector3d V_current_global(ocean_current.first, ocean_current.second, 0.0);
                // Convert global velocity to body frame (R^T * V_current_global)
                const Eigen::Vector3d V_current_body = R.transpose() * V_current_global;
                // Compute Net Velocity in Body Frame
                Eigen::Matrix<double, 6, 1> V_net = dynamics.V;
                V_net.head(3) += V_current_body;  // Add only the linear velocity components
                // Set deflection matrix
                dynamics.X = V_net * dynamics.time_step_size/1000.0;
            }


            /**
             * @brief Updates the ASV's position and attitude based on its deflection.
             * 
             * This function updates the ASV's attitude (roll, pitch, yaw) and position (x, y, z) by 
             * integrating the deflection vector over the current time step. The attitude is updated 
             * by adding the corresponding deflection components, and the position is updated by 
             * rotating the deflection from the body-fixed frame to the global frame.
             * 
             * Steps:
             * - The attitude angles (roll, pitch, yaw) are updated and normalised to ensure they remain 
             *   within the valid range of [-PI, PI].
             * - A rotation matrix is created using the updated attitude to rotate the deflection vector 
             *   from the body frame to the global frame.
             * - The new position is computed by adding the rotated deflection vector to the current position.
             * 
             * @note The attitude is updated using the intrinsic Z-Y-X rotation sequence (yaw-pitch-roll).
             */
            void set_pose() {
                // First set attitude
                dynamics.attitude.keys.x = Geometry::normalise_angle_PI(dynamics.attitude.keys.x + dynamics.X(3));
                dynamics.attitude.keys.y = Geometry::normalise_angle_PI(dynamics.attitude.keys.y + dynamics.X(4));
                dynamics.attitude.keys.z = Geometry::normalise_angle_PI(dynamics.attitude.keys.z + dynamics.X(5)); 
            
                // Create rotation matrix (intrinsic Z-Y-X: yaw -> pitch -> roll)
                const Eigen::Matrix3d R (Eigen::AngleAxisd(dynamics.attitude.keys.z, Eigen::Vector3d::UnitZ())*  // yaw  
                                         Eigen::AngleAxisd(dynamics.attitude.keys.y, Eigen::Vector3d::UnitY())*  // pitch 
                                         Eigen::AngleAxisd(dynamics.attitude.keys.x, Eigen::Vector3d::UnitX())); // roll 
                // Rotate Deflection Vector from Body Frame to Global Frame
                const Eigen::Vector3d X_global = R * dynamics.X.topRows(3);
                // Compute New Position in Global Frame
                const Eigen::Vector3d current_position {dynamics.position.keys.x, dynamics.position.keys.y, dynamics.position.keys.z};
                const Eigen::Vector3d new_position = current_position + X_global;
                dynamics.position.keys.x = new_position(0);
                dynamics.position.keys.y = new_position(1);
                dynamics.position.keys.z = new_position(2);
            }
            
        
        private:

            // ASV specification
            /** @brief Geometric specifications of the ASV (e.g., length, breadth, draught). */
            const AsvSpecification spec;

            /** @brief Pointer to the irregular sea surface model affecting the ASV. */
            const SeaSurface<N>* sea_surface;

            /** @brief Zonal and meridional velocities of the ocean current (in m/s). */
            std::pair<double, double> ocean_current{0.0, 0.0};

            /** @brief Flag to halt surge and sway motions of the ASV. Set to true to keep the ASV stationary. */
            bool halt_surge_and_sway {false};

            /** @brief Dynamics and state variables of the ASV, including position, velocity, and forces. */
            AsvDynamics dynamics;    

    };



    /**
     * @brief Computes the position and magnitude of propulsive thrust generated by the subsurface gliders.
     * 
     * This function calculates the thrust generated by a wave glider based on its current velocity, 
     * rudder angle, and significant wave height. The thrust is computed in two components:
     * 1. **Thrust from hydrofoils**: Calculated based on the hydrodynamic properties of the wave glider's hydrofoils, 
     *    including the lift and drag forces, the velocity of the glider's heave motion, and a tuning factor based on wave height.
     * 2. **Thrust from the rudder**: Computed from the rudder's lift force, which depends on the rudder angle and the surge velocity.
     * 
     * The thrust position is assumed to be located at the center of the wave glider's body, and thrust magnitude is 
     * scaled by factors depending on the wave height and vehicle parameters.
     * 
     * @param wave_glider Reference to the ASV (wave glider) for which thrust is being calculated.
     * @param rudder_angle Angle of the rudder relative to the X-axis of the ASV, in radians. The angle is positive 
     *        when the vehicle turns to starboard (aft of the rudder points to starboard side).
     * @param significant_wave_ht Significant wave height (in meters), used to tune the thrust calculation.
     * 
     * @return std::pair<Geometry::Coordinates3D, Geometry::Coordinates3D> 
     *         - The first component is the thrust position vector in the body frame.
     *         - The second component is the thrust magnitude vector, with thrust components in the X and Y directions.
     * 
     * @note The thrust from hydrofoils is computed considering a 6-hydrofoil configuration, with specific geometric 
     *       parameters and lift-drag relationships. The rudder thrust is computed as a lift-based force.
     * 
     * @ref Dynamic modeling and simulations of the wave glider, Peng Wang, Xinliang Tian, Wenyue Lu, Zhihuan Hu, Yong Luo.
     */
    template<size_t N>
    std::pair<Geometry::Coordinates3D, Geometry::Coordinates3D> get_wave_glider_thrust(const Asv<N>& wave_glider, const double rudder_angle, const double significant_wave_ht) {
        auto wave_glider_spec = wave_glider.get_spec(); 
        
        std::pair<Geometry::Coordinates3D, Geometry::Coordinates3D> return_value;
        return_value.first = {-wave_glider_spec.L_wl/2, 0, 0}; // Thrust position
        return_value.second = {0, 0, 0}; // Thrust magnitude

        // Ref: Dynamic modeling and simulations of the wave glider, Peng Wang, Xinliang Tian, Wenyue Lu, Zhihuan Hu, Yong Luo
        // Compute the thrust generated by the glider
        // Glider details:
        // Number of hydrofoils = 6
        // Area of one hydrofoil (A) = 0.113 m2
        // Angle of attack (alpha_k) = 18 deg
        // Aspect ration (lambda) = 2
        // Cross flow damping coefficient (C_DC) = 0.6
        // 1/4 angle of sweepback (chi) = 7 deg
        // Lift force from one hydrofoil (F_L) = 0.5 * rho * C_L * A * V^2
        // where: 
        // C_L = (1.8 * PI * lambda * alpha_k) / (cos(chi) * sqrt(lambda^2/cos^4(chi) + 4) + 1.8) + (C_DC * alpha_k^2 / lambda)
        // V = heave velocity
        const int count_hydrofoils = 6;
        const double A = 0.113; // m2
        const double alpha_k = 18.0 * M_PI/180.0; // radians
        const double alpha_f_1 = 45.0 * M_PI/180.0; // radians
        const double chi = 7.0 * M_PI/180.0; // radian
        const double lambda = 2.0;
        const double C_DC = 0.6;
        const double C_DO = 0.008;
        const double C_L_1 = (1.8 * M_PI * lambda * alpha_k) / (cos(chi) * sqrt(lambda*lambda/pow(cos(chi), 4) + 4) + 1.8) + (C_DC/ lambda * alpha_k*alpha_k);
        const double C_D = C_DO + C_L_1*C_L_1 / (0.9 * M_PI * lambda);
        const double V_heave = wave_glider.get_velocity().keys.heave;
        const double F_L = 0.5 * Constants::SEA_WATER_DENSITY * C_L_1 * A * V_heave*V_heave;
        const double F_D = 0.5 * Constants::SEA_WATER_DENSITY * C_D * A * V_heave*V_heave;
        const double thrust_per_hydrofoil = F_L * sin(alpha_f_1) - F_D * cos(alpha_f_1);
        const double thrust = count_hydrofoils * thrust_per_hydrofoil;
        
        double thrust_tuning_factor = 0.0;
        if(significant_wave_ht < 1.0) {
            thrust_tuning_factor = 0.0496;
        } else if(significant_wave_ht >= 1.0 && significant_wave_ht < 2.0) {
            thrust_tuning_factor = 0.0330;
        } else if (significant_wave_ht >= 2.0 && significant_wave_ht < 3.0) {
            thrust_tuning_factor = 0.0288;
        } else if (significant_wave_ht >= 3.0 && significant_wave_ht < 4.0) {
            thrust_tuning_factor = 0.0248;
        } else if (significant_wave_ht >= 4.0 && significant_wave_ht < 5.0) {
            thrust_tuning_factor = 0.0202;
        } else if (significant_wave_ht >= 5.0 && significant_wave_ht < 6.0) {
            thrust_tuning_factor = 0.0157;
        } else if (significant_wave_ht >= 6.0 && significant_wave_ht < 7.0) {
            thrust_tuning_factor = 0.0147;
        } else if (significant_wave_ht >= 7.0 && significant_wave_ht < 8.0) {
            thrust_tuning_factor = 0.0141;
        } else {
            thrust_tuning_factor = 0.0133;
        }
        
        return_value.second.keys.x = thrust_tuning_factor * thrust;

        // Compute the thrust generated by the rudder
        // Assuming the rudder area = area of a hydrofoil
        const double A_rudder = 0.4 * 0.2 ; // m2
        const double alpha_f_2 = rudder_angle; // radians
        const double V_surge = wave_glider.get_velocity().keys.surge;
        const double C_L_2 = (1.8 * M_PI * lambda * alpha_k) / (cos(chi) * sqrt(lambda*lambda/pow(cos(chi), 4) + 4) + 1.8) + (C_DC/ lambda * alpha_k*alpha_k);
        const double F_L_rudder = 0.5 * Constants::SEA_WATER_DENSITY * C_L_2 * A_rudder * V_surge * V_surge;
        double rudder_thrust = F_L_rudder * sin(alpha_f_2);
        // rudder_thrust = (rudder_angle < 0.0)? -rudder_thrust: rudder_thrust;
        return_value.second.keys.y = rudder_thrust;

        return return_value;
    } 

}